/*
 * Copyright 2019-2020 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .data

  .globl _libfmod_so_tramp_table
  .hidden _libfmod_so_tramp_table
  .align 4
_libfmod_so_tramp_table:
  .zero 4364

  .text

  .globl _libfmod_so_tramp_resolve
  .hidden _libfmod_so_tramp_resolve

  .globl _libfmod_so_save_regs_and_resolve
  .hidden _libfmod_so_save_regs_and_resolve
  .type _libfmod_so_save_regs_and_resolve, %function
_libfmod_so_save_regs_and_resolve:
  .cfi_startproc

#define PUSH_REG(reg) pushl %reg ; .cfi_adjust_cfa_offset 4; .cfi_rel_offset reg, 0
#define POP_REG(reg) popl %reg ; .cfi_adjust_cfa_offset -4; .cfi_restore reg

  // Slow path which calls dlsym, taken only on first call.
  // All registers are stored to handle arbitrary calling conventions
  // (except XMM/x87 regs in hope they are not used in resolving code).
  // For Dwarf directives, read https://www.imperialviolet.org/2017/01/18/cfi.html.

  .cfi_def_cfa_offset 4  // Return address

  PUSH_REG(eax)
  PUSH_REG(ebx)
  PUSH_REG(ecx)
  PUSH_REG(edx)  // 16

  PUSH_REG(ebp)
  PUSH_REG(edi)
  PUSH_REG(esi)
  pushfl; .cfi_adjust_cfa_offset 4  // 16

  subl $8, %esp
  .cfi_adjust_cfa_offset 8
  PUSH_REG(eax)

  call _libfmod_so_tramp_resolve@PLT  // Stack will be aligned at 16 in call

  addl $12, %esp
  .cfi_adjust_cfa_offset -12

  popfl; .cfi_adjust_cfa_offset -4
  POP_REG(esi)
  POP_REG(edi)
  POP_REG(ebp)

  POP_REG(edx)
  POP_REG(ecx)
  POP_REG(ebx)
  POP_REG(eax)

  ret

  .cfi_endproc

  .section .text.__implib.x86.get_pc_thunk.ax,"axG",@progbits,__implib.x86.get_pc_thunk.ax,comdat
  .globl __implib.x86.get_pc_thunk.ax
  .hidden __implib.x86.get_pc_thunk.ax
  .type __implib.x86.get_pc_thunk.ax, %function
__implib.x86.get_pc_thunk.ax:
  .cfi_startproc
  movl (%esp), %eax
  ret
  .cfi_endproc

/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_AddDSP
  .p2align 4
  .type FMOD5_ChannelGroup_AddDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_AddDSP
#endif
FMOD5_ChannelGroup_AddDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 0+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $0, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_AddDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_AddFadePoint
  .p2align 4
  .type FMOD5_ChannelGroup_AddFadePoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_AddFadePoint
#endif
FMOD5_ChannelGroup_AddFadePoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_AddFadePoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_AddGroup
  .p2align 4
  .type FMOD5_ChannelGroup_AddGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_AddGroup
#endif
FMOD5_ChannelGroup_AddGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 8+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $2, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_AddGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DAttributes
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DAttributes
#endif
FMOD5_ChannelGroup_Get3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 12+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $3, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DConeOrientation
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DConeOrientation
#endif
FMOD5_ChannelGroup_Get3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 16+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $4, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DConeSettings
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DConeSettings
#endif
FMOD5_ChannelGroup_Get3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 20+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $5, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DCustomRolloff
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DCustomRolloff
#endif
FMOD5_ChannelGroup_Get3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 24+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $6, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DDistanceFilter
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DDistanceFilter
#endif
FMOD5_ChannelGroup_Get3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 28+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $7, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DDopplerLevel
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DDopplerLevel
#endif
FMOD5_ChannelGroup_Get3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 32+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $8, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DLevel
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DLevel
#endif
FMOD5_ChannelGroup_Get3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 36+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $9, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DMinMaxDistance
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DMinMaxDistance
#endif
FMOD5_ChannelGroup_Get3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 40+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $10, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DOcclusion
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DOcclusion
#endif
FMOD5_ChannelGroup_Get3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 44+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $11, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Get3DSpread
  .p2align 4
  .type FMOD5_ChannelGroup_Get3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Get3DSpread
#endif
FMOD5_ChannelGroup_Get3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 48+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $12, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Get3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetAudibility
  .p2align 4
  .type FMOD5_ChannelGroup_GetAudibility, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetAudibility
#endif
FMOD5_ChannelGroup_GetAudibility:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 52+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $13, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetAudibility
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetChannel
  .p2align 4
  .type FMOD5_ChannelGroup_GetChannel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetChannel
#endif
FMOD5_ChannelGroup_GetChannel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 56+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $14, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetChannel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetDSP
  .p2align 4
  .type FMOD5_ChannelGroup_GetDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetDSP
#endif
FMOD5_ChannelGroup_GetDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 60+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $15, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetDSPClock
  .p2align 4
  .type FMOD5_ChannelGroup_GetDSPClock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetDSPClock
#endif
FMOD5_ChannelGroup_GetDSPClock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 64+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $16, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetDSPClock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetDSPIndex
  .p2align 4
  .type FMOD5_ChannelGroup_GetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetDSPIndex
#endif
FMOD5_ChannelGroup_GetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 68+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $17, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetDelay
  .p2align 4
  .type FMOD5_ChannelGroup_GetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetDelay
#endif
FMOD5_ChannelGroup_GetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 72+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $18, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetFadePoints
  .p2align 4
  .type FMOD5_ChannelGroup_GetFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetFadePoints
#endif
FMOD5_ChannelGroup_GetFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 76+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $19, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetGroup
  .p2align 4
  .type FMOD5_ChannelGroup_GetGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetGroup
#endif
FMOD5_ChannelGroup_GetGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 80+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $20, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetLowPassGain
  .p2align 4
  .type FMOD5_ChannelGroup_GetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetLowPassGain
#endif
FMOD5_ChannelGroup_GetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 84+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $21, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetMixMatrix
  .p2align 4
  .type FMOD5_ChannelGroup_GetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetMixMatrix
#endif
FMOD5_ChannelGroup_GetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 88+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $22, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetMode
  .p2align 4
  .type FMOD5_ChannelGroup_GetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetMode
#endif
FMOD5_ChannelGroup_GetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 92+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $23, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetMute
  .p2align 4
  .type FMOD5_ChannelGroup_GetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetMute
#endif
FMOD5_ChannelGroup_GetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 96+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $24, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetName
  .p2align 4
  .type FMOD5_ChannelGroup_GetName, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetName
#endif
FMOD5_ChannelGroup_GetName:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 100+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $25, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetName
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetNumChannels
  .p2align 4
  .type FMOD5_ChannelGroup_GetNumChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetNumChannels
#endif
FMOD5_ChannelGroup_GetNumChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 104+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $26, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetNumChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetNumDSPs
  .p2align 4
  .type FMOD5_ChannelGroup_GetNumDSPs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetNumDSPs
#endif
FMOD5_ChannelGroup_GetNumDSPs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 108+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $27, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetNumDSPs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetNumGroups
  .p2align 4
  .type FMOD5_ChannelGroup_GetNumGroups, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetNumGroups
#endif
FMOD5_ChannelGroup_GetNumGroups:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 112+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $28, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetNumGroups
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetParentGroup
  .p2align 4
  .type FMOD5_ChannelGroup_GetParentGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetParentGroup
#endif
FMOD5_ChannelGroup_GetParentGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 116+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $29, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetParentGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetPaused
  .p2align 4
  .type FMOD5_ChannelGroup_GetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetPaused
#endif
FMOD5_ChannelGroup_GetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 120+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $30, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetPitch
  .p2align 4
  .type FMOD5_ChannelGroup_GetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetPitch
#endif
FMOD5_ChannelGroup_GetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 124+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $31, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetReverbProperties
  .p2align 4
  .type FMOD5_ChannelGroup_GetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetReverbProperties
#endif
FMOD5_ChannelGroup_GetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 128+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $32, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetSystemObject
  .p2align 4
  .type FMOD5_ChannelGroup_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetSystemObject
#endif
FMOD5_ChannelGroup_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 132+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $33, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetUserData
  .p2align 4
  .type FMOD5_ChannelGroup_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetUserData
#endif
FMOD5_ChannelGroup_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 136+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $34, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetVolume
  .p2align 4
  .type FMOD5_ChannelGroup_GetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetVolume
#endif
FMOD5_ChannelGroup_GetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 140+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $35, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_GetVolumeRamp
  .p2align 4
  .type FMOD5_ChannelGroup_GetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_GetVolumeRamp
#endif
FMOD5_ChannelGroup_GetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 144+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $36, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_GetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_IsPlaying
  .p2align 4
  .type FMOD5_ChannelGroup_IsPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_IsPlaying
#endif
FMOD5_ChannelGroup_IsPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 148+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $37, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_IsPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Release
  .p2align 4
  .type FMOD5_ChannelGroup_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Release
#endif
FMOD5_ChannelGroup_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 152+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $38, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_RemoveDSP
  .p2align 4
  .type FMOD5_ChannelGroup_RemoveDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_RemoveDSP
#endif
FMOD5_ChannelGroup_RemoveDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 156+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $39, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_RemoveDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_RemoveFadePoints
  .p2align 4
  .type FMOD5_ChannelGroup_RemoveFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_RemoveFadePoints
#endif
FMOD5_ChannelGroup_RemoveFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 160+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $40, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_RemoveFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DAttributes
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DAttributes
#endif
FMOD5_ChannelGroup_Set3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 164+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $41, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DConeOrientation
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DConeOrientation
#endif
FMOD5_ChannelGroup_Set3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 168+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $42, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DConeSettings
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DConeSettings
#endif
FMOD5_ChannelGroup_Set3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 172+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $43, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DCustomRolloff
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DCustomRolloff
#endif
FMOD5_ChannelGroup_Set3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 176+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $44, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DDistanceFilter
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DDistanceFilter
#endif
FMOD5_ChannelGroup_Set3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 180+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $45, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DDopplerLevel
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DDopplerLevel
#endif
FMOD5_ChannelGroup_Set3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 184+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $46, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DLevel
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DLevel
#endif
FMOD5_ChannelGroup_Set3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 188+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $47, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DMinMaxDistance
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DMinMaxDistance
#endif
FMOD5_ChannelGroup_Set3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 192+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $48, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DOcclusion
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DOcclusion
#endif
FMOD5_ChannelGroup_Set3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 196+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $49, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Set3DSpread
  .p2align 4
  .type FMOD5_ChannelGroup_Set3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Set3DSpread
#endif
FMOD5_ChannelGroup_Set3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 200+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $50, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Set3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetCallback
  .p2align 4
  .type FMOD5_ChannelGroup_SetCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetCallback
#endif
FMOD5_ChannelGroup_SetCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 204+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $51, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetDSPIndex
  .p2align 4
  .type FMOD5_ChannelGroup_SetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetDSPIndex
#endif
FMOD5_ChannelGroup_SetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 208+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $52, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetDelay
  .p2align 4
  .type FMOD5_ChannelGroup_SetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetDelay
#endif
FMOD5_ChannelGroup_SetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 212+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $53, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetFadePointRamp
  .p2align 4
  .type FMOD5_ChannelGroup_SetFadePointRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetFadePointRamp
#endif
FMOD5_ChannelGroup_SetFadePointRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 216+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $54, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetFadePointRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetLowPassGain
  .p2align 4
  .type FMOD5_ChannelGroup_SetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetLowPassGain
#endif
FMOD5_ChannelGroup_SetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 220+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $55, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetMixLevelsInput
  .p2align 4
  .type FMOD5_ChannelGroup_SetMixLevelsInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetMixLevelsInput
#endif
FMOD5_ChannelGroup_SetMixLevelsInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 224+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $56, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetMixLevelsInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetMixLevelsOutput
  .p2align 4
  .type FMOD5_ChannelGroup_SetMixLevelsOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetMixLevelsOutput
#endif
FMOD5_ChannelGroup_SetMixLevelsOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 228+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $57, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetMixLevelsOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetMixMatrix
  .p2align 4
  .type FMOD5_ChannelGroup_SetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetMixMatrix
#endif
FMOD5_ChannelGroup_SetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 232+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $58, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetMode
  .p2align 4
  .type FMOD5_ChannelGroup_SetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetMode
#endif
FMOD5_ChannelGroup_SetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 236+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $59, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetMute
  .p2align 4
  .type FMOD5_ChannelGroup_SetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetMute
#endif
FMOD5_ChannelGroup_SetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 240+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $60, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetPan
  .p2align 4
  .type FMOD5_ChannelGroup_SetPan, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetPan
#endif
FMOD5_ChannelGroup_SetPan:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 244+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $61, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetPan
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetPaused
  .p2align 4
  .type FMOD5_ChannelGroup_SetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetPaused
#endif
FMOD5_ChannelGroup_SetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 248+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $62, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetPitch
  .p2align 4
  .type FMOD5_ChannelGroup_SetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetPitch
#endif
FMOD5_ChannelGroup_SetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 252+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $63, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetReverbProperties
  .p2align 4
  .type FMOD5_ChannelGroup_SetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetReverbProperties
#endif
FMOD5_ChannelGroup_SetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 256+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $64, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetUserData
  .p2align 4
  .type FMOD5_ChannelGroup_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetUserData
#endif
FMOD5_ChannelGroup_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 260+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $65, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetVolume
  .p2align 4
  .type FMOD5_ChannelGroup_SetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetVolume
#endif
FMOD5_ChannelGroup_SetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 264+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $66, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_SetVolumeRamp
  .p2align 4
  .type FMOD5_ChannelGroup_SetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_SetVolumeRamp
#endif
FMOD5_ChannelGroup_SetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 268+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $67, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_SetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_ChannelGroup_Stop
  .p2align 4
  .type FMOD5_ChannelGroup_Stop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_ChannelGroup_Stop
#endif
FMOD5_ChannelGroup_Stop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 272+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $68, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_ChannelGroup_Stop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_AddDSP
  .p2align 4
  .type FMOD5_Channel_AddDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_AddDSP
#endif
FMOD5_Channel_AddDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 276+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $69, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_AddDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_AddFadePoint
  .p2align 4
  .type FMOD5_Channel_AddFadePoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_AddFadePoint
#endif
FMOD5_Channel_AddFadePoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 280+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $70, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_AddFadePoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DAttributes
  .p2align 4
  .type FMOD5_Channel_Get3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DAttributes
#endif
FMOD5_Channel_Get3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 284+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $71, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DConeOrientation
  .p2align 4
  .type FMOD5_Channel_Get3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DConeOrientation
#endif
FMOD5_Channel_Get3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 288+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $72, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DConeSettings
  .p2align 4
  .type FMOD5_Channel_Get3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DConeSettings
#endif
FMOD5_Channel_Get3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 292+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $73, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DCustomRolloff
  .p2align 4
  .type FMOD5_Channel_Get3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DCustomRolloff
#endif
FMOD5_Channel_Get3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 296+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $74, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DDistanceFilter
  .p2align 4
  .type FMOD5_Channel_Get3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DDistanceFilter
#endif
FMOD5_Channel_Get3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 300+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $75, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DDopplerLevel
  .p2align 4
  .type FMOD5_Channel_Get3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DDopplerLevel
#endif
FMOD5_Channel_Get3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 304+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $76, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DLevel
  .p2align 4
  .type FMOD5_Channel_Get3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DLevel
#endif
FMOD5_Channel_Get3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 308+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $77, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DMinMaxDistance
  .p2align 4
  .type FMOD5_Channel_Get3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DMinMaxDistance
#endif
FMOD5_Channel_Get3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 312+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $78, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DOcclusion
  .p2align 4
  .type FMOD5_Channel_Get3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DOcclusion
#endif
FMOD5_Channel_Get3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 316+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $79, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Get3DSpread
  .p2align 4
  .type FMOD5_Channel_Get3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Get3DSpread
#endif
FMOD5_Channel_Get3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 320+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $80, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Get3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetAudibility
  .p2align 4
  .type FMOD5_Channel_GetAudibility, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetAudibility
#endif
FMOD5_Channel_GetAudibility:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 324+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $81, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetAudibility
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetChannelGroup
  .p2align 4
  .type FMOD5_Channel_GetChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetChannelGroup
#endif
FMOD5_Channel_GetChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 328+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $82, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetCurrentSound
  .p2align 4
  .type FMOD5_Channel_GetCurrentSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetCurrentSound
#endif
FMOD5_Channel_GetCurrentSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 332+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $83, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetCurrentSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetDSP
  .p2align 4
  .type FMOD5_Channel_GetDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetDSP
#endif
FMOD5_Channel_GetDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 336+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $84, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetDSPClock
  .p2align 4
  .type FMOD5_Channel_GetDSPClock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetDSPClock
#endif
FMOD5_Channel_GetDSPClock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 340+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $85, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetDSPClock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetDSPIndex
  .p2align 4
  .type FMOD5_Channel_GetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetDSPIndex
#endif
FMOD5_Channel_GetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 344+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $86, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetDelay
  .p2align 4
  .type FMOD5_Channel_GetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetDelay
#endif
FMOD5_Channel_GetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 348+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $87, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetFadePoints
  .p2align 4
  .type FMOD5_Channel_GetFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetFadePoints
#endif
FMOD5_Channel_GetFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 352+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $88, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetFrequency
  .p2align 4
  .type FMOD5_Channel_GetFrequency, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetFrequency
#endif
FMOD5_Channel_GetFrequency:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 356+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $89, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetFrequency
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetIndex
  .p2align 4
  .type FMOD5_Channel_GetIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetIndex
#endif
FMOD5_Channel_GetIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 360+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $90, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetLoopCount
  .p2align 4
  .type FMOD5_Channel_GetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetLoopCount
#endif
FMOD5_Channel_GetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 364+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $91, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetLoopPoints
  .p2align 4
  .type FMOD5_Channel_GetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetLoopPoints
#endif
FMOD5_Channel_GetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 368+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $92, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetLowPassGain
  .p2align 4
  .type FMOD5_Channel_GetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetLowPassGain
#endif
FMOD5_Channel_GetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 372+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $93, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetMixMatrix
  .p2align 4
  .type FMOD5_Channel_GetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetMixMatrix
#endif
FMOD5_Channel_GetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 376+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $94, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetMode
  .p2align 4
  .type FMOD5_Channel_GetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetMode
#endif
FMOD5_Channel_GetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 380+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $95, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetMute
  .p2align 4
  .type FMOD5_Channel_GetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetMute
#endif
FMOD5_Channel_GetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 384+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $96, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetNumDSPs
  .p2align 4
  .type FMOD5_Channel_GetNumDSPs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetNumDSPs
#endif
FMOD5_Channel_GetNumDSPs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 388+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $97, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetNumDSPs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetPaused
  .p2align 4
  .type FMOD5_Channel_GetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetPaused
#endif
FMOD5_Channel_GetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 392+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $98, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetPitch
  .p2align 4
  .type FMOD5_Channel_GetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetPitch
#endif
FMOD5_Channel_GetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 396+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $99, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetPosition
  .p2align 4
  .type FMOD5_Channel_GetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetPosition
#endif
FMOD5_Channel_GetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 400+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $100, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetPriority
  .p2align 4
  .type FMOD5_Channel_GetPriority, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetPriority
#endif
FMOD5_Channel_GetPriority:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 404+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $101, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetPriority
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetReverbProperties
  .p2align 4
  .type FMOD5_Channel_GetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetReverbProperties
#endif
FMOD5_Channel_GetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 408+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $102, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetSystemObject
  .p2align 4
  .type FMOD5_Channel_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetSystemObject
#endif
FMOD5_Channel_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 412+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $103, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetUserData
  .p2align 4
  .type FMOD5_Channel_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetUserData
#endif
FMOD5_Channel_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 416+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $104, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetVolume
  .p2align 4
  .type FMOD5_Channel_GetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetVolume
#endif
FMOD5_Channel_GetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 420+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $105, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_GetVolumeRamp
  .p2align 4
  .type FMOD5_Channel_GetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_GetVolumeRamp
#endif
FMOD5_Channel_GetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 424+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $106, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_GetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_IsPlaying
  .p2align 4
  .type FMOD5_Channel_IsPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_IsPlaying
#endif
FMOD5_Channel_IsPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 428+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $107, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_IsPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_IsVirtual
  .p2align 4
  .type FMOD5_Channel_IsVirtual, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_IsVirtual
#endif
FMOD5_Channel_IsVirtual:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 432+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $108, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_IsVirtual
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_RemoveDSP
  .p2align 4
  .type FMOD5_Channel_RemoveDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_RemoveDSP
#endif
FMOD5_Channel_RemoveDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 436+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $109, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_RemoveDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_RemoveFadePoints
  .p2align 4
  .type FMOD5_Channel_RemoveFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_RemoveFadePoints
#endif
FMOD5_Channel_RemoveFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 440+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $110, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_RemoveFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DAttributes
  .p2align 4
  .type FMOD5_Channel_Set3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DAttributes
#endif
FMOD5_Channel_Set3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 444+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $111, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DConeOrientation
  .p2align 4
  .type FMOD5_Channel_Set3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DConeOrientation
#endif
FMOD5_Channel_Set3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 448+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $112, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DConeSettings
  .p2align 4
  .type FMOD5_Channel_Set3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DConeSettings
#endif
FMOD5_Channel_Set3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 452+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $113, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DCustomRolloff
  .p2align 4
  .type FMOD5_Channel_Set3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DCustomRolloff
#endif
FMOD5_Channel_Set3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 456+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $114, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DDistanceFilter
  .p2align 4
  .type FMOD5_Channel_Set3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DDistanceFilter
#endif
FMOD5_Channel_Set3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 460+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $115, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DDopplerLevel
  .p2align 4
  .type FMOD5_Channel_Set3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DDopplerLevel
#endif
FMOD5_Channel_Set3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 464+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $116, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DLevel
  .p2align 4
  .type FMOD5_Channel_Set3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DLevel
#endif
FMOD5_Channel_Set3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 468+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $117, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DMinMaxDistance
  .p2align 4
  .type FMOD5_Channel_Set3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DMinMaxDistance
#endif
FMOD5_Channel_Set3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 472+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $118, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DOcclusion
  .p2align 4
  .type FMOD5_Channel_Set3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DOcclusion
#endif
FMOD5_Channel_Set3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 476+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $119, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Set3DSpread
  .p2align 4
  .type FMOD5_Channel_Set3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Set3DSpread
#endif
FMOD5_Channel_Set3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 480+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $120, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Set3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetCallback
  .p2align 4
  .type FMOD5_Channel_SetCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetCallback
#endif
FMOD5_Channel_SetCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 484+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $121, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetChannelGroup
  .p2align 4
  .type FMOD5_Channel_SetChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetChannelGroup
#endif
FMOD5_Channel_SetChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 488+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $122, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetDSPIndex
  .p2align 4
  .type FMOD5_Channel_SetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetDSPIndex
#endif
FMOD5_Channel_SetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 492+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $123, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetDelay
  .p2align 4
  .type FMOD5_Channel_SetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetDelay
#endif
FMOD5_Channel_SetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 496+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $124, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetFadePointRamp
  .p2align 4
  .type FMOD5_Channel_SetFadePointRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetFadePointRamp
#endif
FMOD5_Channel_SetFadePointRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 500+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $125, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetFadePointRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetFrequency
  .p2align 4
  .type FMOD5_Channel_SetFrequency, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetFrequency
#endif
FMOD5_Channel_SetFrequency:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 504+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $126, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetFrequency
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetLoopCount
  .p2align 4
  .type FMOD5_Channel_SetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetLoopCount
#endif
FMOD5_Channel_SetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 508+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $127, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetLoopPoints
  .p2align 4
  .type FMOD5_Channel_SetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetLoopPoints
#endif
FMOD5_Channel_SetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 512+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $128, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetLowPassGain
  .p2align 4
  .type FMOD5_Channel_SetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetLowPassGain
#endif
FMOD5_Channel_SetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 516+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $129, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetMixLevelsInput
  .p2align 4
  .type FMOD5_Channel_SetMixLevelsInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetMixLevelsInput
#endif
FMOD5_Channel_SetMixLevelsInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 520+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $130, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetMixLevelsInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetMixLevelsOutput
  .p2align 4
  .type FMOD5_Channel_SetMixLevelsOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetMixLevelsOutput
#endif
FMOD5_Channel_SetMixLevelsOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 524+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $131, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetMixLevelsOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetMixMatrix
  .p2align 4
  .type FMOD5_Channel_SetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetMixMatrix
#endif
FMOD5_Channel_SetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 528+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $132, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetMode
  .p2align 4
  .type FMOD5_Channel_SetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetMode
#endif
FMOD5_Channel_SetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 532+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $133, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetMute
  .p2align 4
  .type FMOD5_Channel_SetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetMute
#endif
FMOD5_Channel_SetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 536+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $134, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetPan
  .p2align 4
  .type FMOD5_Channel_SetPan, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetPan
#endif
FMOD5_Channel_SetPan:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 540+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $135, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetPan
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetPaused
  .p2align 4
  .type FMOD5_Channel_SetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetPaused
#endif
FMOD5_Channel_SetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 544+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $136, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetPitch
  .p2align 4
  .type FMOD5_Channel_SetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetPitch
#endif
FMOD5_Channel_SetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 548+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $137, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetPosition
  .p2align 4
  .type FMOD5_Channel_SetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetPosition
#endif
FMOD5_Channel_SetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 552+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $138, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetPriority
  .p2align 4
  .type FMOD5_Channel_SetPriority, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetPriority
#endif
FMOD5_Channel_SetPriority:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 556+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $139, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetPriority
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetReverbProperties
  .p2align 4
  .type FMOD5_Channel_SetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetReverbProperties
#endif
FMOD5_Channel_SetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 560+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $140, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetUserData
  .p2align 4
  .type FMOD5_Channel_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetUserData
#endif
FMOD5_Channel_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 564+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $141, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetVolume
  .p2align 4
  .type FMOD5_Channel_SetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetVolume
#endif
FMOD5_Channel_SetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 568+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $142, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_SetVolumeRamp
  .p2align 4
  .type FMOD5_Channel_SetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_SetVolumeRamp
#endif
FMOD5_Channel_SetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 572+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $143, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_SetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Channel_Stop
  .p2align 4
  .type FMOD5_Channel_Stop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Channel_Stop
#endif
FMOD5_Channel_Stop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 576+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $144, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Channel_Stop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_GetInput
  .p2align 4
  .type FMOD5_DSPConnection_GetInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_GetInput
#endif
FMOD5_DSPConnection_GetInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 580+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $145, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_GetInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_GetMix
  .p2align 4
  .type FMOD5_DSPConnection_GetMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_GetMix
#endif
FMOD5_DSPConnection_GetMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 584+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $146, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_GetMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_GetMixMatrix
  .p2align 4
  .type FMOD5_DSPConnection_GetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_GetMixMatrix
#endif
FMOD5_DSPConnection_GetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 588+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $147, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_GetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_GetOutput
  .p2align 4
  .type FMOD5_DSPConnection_GetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_GetOutput
#endif
FMOD5_DSPConnection_GetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 592+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $148, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_GetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_GetType
  .p2align 4
  .type FMOD5_DSPConnection_GetType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_GetType
#endif
FMOD5_DSPConnection_GetType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 596+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $149, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_GetType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_GetUserData
  .p2align 4
  .type FMOD5_DSPConnection_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_GetUserData
#endif
FMOD5_DSPConnection_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 600+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $150, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_SetMix
  .p2align 4
  .type FMOD5_DSPConnection_SetMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_SetMix
#endif
FMOD5_DSPConnection_SetMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 604+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $151, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_SetMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_SetMixMatrix
  .p2align 4
  .type FMOD5_DSPConnection_SetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_SetMixMatrix
#endif
FMOD5_DSPConnection_SetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 608+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $152, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_SetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSPConnection_SetUserData
  .p2align 4
  .type FMOD5_DSPConnection_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSPConnection_SetUserData
#endif
FMOD5_DSPConnection_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 612+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $153, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSPConnection_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_AddInput
  .p2align 4
  .type FMOD5_DSP_AddInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_AddInput
#endif
FMOD5_DSP_AddInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 616+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $154, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_AddInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_DisconnectAll
  .p2align 4
  .type FMOD5_DSP_DisconnectAll, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_DisconnectAll
#endif
FMOD5_DSP_DisconnectAll:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 620+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $155, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_DisconnectAll
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_DisconnectFrom
  .p2align 4
  .type FMOD5_DSP_DisconnectFrom, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_DisconnectFrom
#endif
FMOD5_DSP_DisconnectFrom:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 624+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $156, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_DisconnectFrom
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetActive
  .p2align 4
  .type FMOD5_DSP_GetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetActive
#endif
FMOD5_DSP_GetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 628+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $157, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetBypass
  .p2align 4
  .type FMOD5_DSP_GetBypass, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetBypass
#endif
FMOD5_DSP_GetBypass:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 632+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $158, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetBypass
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetCPUUsage
  .p2align 4
  .type FMOD5_DSP_GetCPUUsage, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetCPUUsage
#endif
FMOD5_DSP_GetCPUUsage:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 636+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $159, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetCPUUsage
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetChannelFormat
  .p2align 4
  .type FMOD5_DSP_GetChannelFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetChannelFormat
#endif
FMOD5_DSP_GetChannelFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 640+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $160, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetChannelFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetDataParameterIndex
  .p2align 4
  .type FMOD5_DSP_GetDataParameterIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetDataParameterIndex
#endif
FMOD5_DSP_GetDataParameterIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 644+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $161, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetDataParameterIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetIdle
  .p2align 4
  .type FMOD5_DSP_GetIdle, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetIdle
#endif
FMOD5_DSP_GetIdle:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 648+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $162, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetIdle
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetInfo
  .p2align 4
  .type FMOD5_DSP_GetInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetInfo
#endif
FMOD5_DSP_GetInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 652+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $163, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetInput
  .p2align 4
  .type FMOD5_DSP_GetInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetInput
#endif
FMOD5_DSP_GetInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 656+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $164, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetMeteringEnabled
  .p2align 4
  .type FMOD5_DSP_GetMeteringEnabled, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetMeteringEnabled
#endif
FMOD5_DSP_GetMeteringEnabled:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 660+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $165, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetMeteringEnabled
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetMeteringInfo
  .p2align 4
  .type FMOD5_DSP_GetMeteringInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetMeteringInfo
#endif
FMOD5_DSP_GetMeteringInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 664+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $166, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetMeteringInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetNumInputs
  .p2align 4
  .type FMOD5_DSP_GetNumInputs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetNumInputs
#endif
FMOD5_DSP_GetNumInputs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 668+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $167, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetNumInputs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetNumOutputs
  .p2align 4
  .type FMOD5_DSP_GetNumOutputs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetNumOutputs
#endif
FMOD5_DSP_GetNumOutputs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 672+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $168, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetNumOutputs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetNumParameters
  .p2align 4
  .type FMOD5_DSP_GetNumParameters, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetNumParameters
#endif
FMOD5_DSP_GetNumParameters:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 676+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $169, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetNumParameters
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetOutput
  .p2align 4
  .type FMOD5_DSP_GetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetOutput
#endif
FMOD5_DSP_GetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 680+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $170, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetOutputChannelFormat
  .p2align 4
  .type FMOD5_DSP_GetOutputChannelFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetOutputChannelFormat
#endif
FMOD5_DSP_GetOutputChannelFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 684+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $171, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetOutputChannelFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetParameterBool
  .p2align 4
  .type FMOD5_DSP_GetParameterBool, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetParameterBool
#endif
FMOD5_DSP_GetParameterBool:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 688+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $172, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetParameterBool
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetParameterData
  .p2align 4
  .type FMOD5_DSP_GetParameterData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetParameterData
#endif
FMOD5_DSP_GetParameterData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 692+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $173, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetParameterData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetParameterFloat
  .p2align 4
  .type FMOD5_DSP_GetParameterFloat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetParameterFloat
#endif
FMOD5_DSP_GetParameterFloat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 696+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $174, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetParameterFloat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetParameterInfo
  .p2align 4
  .type FMOD5_DSP_GetParameterInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetParameterInfo
#endif
FMOD5_DSP_GetParameterInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 700+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $175, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetParameterInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetParameterInt
  .p2align 4
  .type FMOD5_DSP_GetParameterInt, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetParameterInt
#endif
FMOD5_DSP_GetParameterInt:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 704+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $176, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetParameterInt
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetSystemObject
  .p2align 4
  .type FMOD5_DSP_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetSystemObject
#endif
FMOD5_DSP_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 708+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $177, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetType
  .p2align 4
  .type FMOD5_DSP_GetType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetType
#endif
FMOD5_DSP_GetType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 712+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $178, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetUserData
  .p2align 4
  .type FMOD5_DSP_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetUserData
#endif
FMOD5_DSP_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 716+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $179, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_GetWetDryMix
  .p2align 4
  .type FMOD5_DSP_GetWetDryMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_GetWetDryMix
#endif
FMOD5_DSP_GetWetDryMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 720+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $180, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_GetWetDryMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_Release
  .p2align 4
  .type FMOD5_DSP_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_Release
#endif
FMOD5_DSP_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 724+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $181, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_Reset
  .p2align 4
  .type FMOD5_DSP_Reset, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_Reset
#endif
FMOD5_DSP_Reset:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 728+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $182, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_Reset
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetActive
  .p2align 4
  .type FMOD5_DSP_SetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetActive
#endif
FMOD5_DSP_SetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 732+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $183, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetBypass
  .p2align 4
  .type FMOD5_DSP_SetBypass, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetBypass
#endif
FMOD5_DSP_SetBypass:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 736+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $184, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetBypass
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetChannelFormat
  .p2align 4
  .type FMOD5_DSP_SetChannelFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetChannelFormat
#endif
FMOD5_DSP_SetChannelFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 740+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $185, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetChannelFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetMeteringEnabled
  .p2align 4
  .type FMOD5_DSP_SetMeteringEnabled, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetMeteringEnabled
#endif
FMOD5_DSP_SetMeteringEnabled:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 744+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $186, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetMeteringEnabled
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetParameterBool
  .p2align 4
  .type FMOD5_DSP_SetParameterBool, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetParameterBool
#endif
FMOD5_DSP_SetParameterBool:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 748+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $187, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetParameterBool
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetParameterData
  .p2align 4
  .type FMOD5_DSP_SetParameterData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetParameterData
#endif
FMOD5_DSP_SetParameterData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 752+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $188, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetParameterData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetParameterFloat
  .p2align 4
  .type FMOD5_DSP_SetParameterFloat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetParameterFloat
#endif
FMOD5_DSP_SetParameterFloat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 756+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $189, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetParameterFloat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetParameterInt
  .p2align 4
  .type FMOD5_DSP_SetParameterInt, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetParameterInt
#endif
FMOD5_DSP_SetParameterInt:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 760+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $190, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetParameterInt
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetUserData
  .p2align 4
  .type FMOD5_DSP_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetUserData
#endif
FMOD5_DSP_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 764+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $191, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_SetWetDryMix
  .p2align 4
  .type FMOD5_DSP_SetWetDryMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_SetWetDryMix
#endif
FMOD5_DSP_SetWetDryMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 768+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $192, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_SetWetDryMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_DSP_ShowConfigDialog
  .p2align 4
  .type FMOD5_DSP_ShowConfigDialog, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_DSP_ShowConfigDialog
#endif
FMOD5_DSP_ShowConfigDialog:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 772+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $193, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_DSP_ShowConfigDialog
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Debug_Initialize
  .p2align 4
  .type FMOD5_Debug_Initialize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Debug_Initialize
#endif
FMOD5_Debug_Initialize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 776+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $194, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Debug_Initialize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_File_GetDiskBusy
  .p2align 4
  .type FMOD5_File_GetDiskBusy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_File_GetDiskBusy
#endif
FMOD5_File_GetDiskBusy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 780+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $195, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_File_GetDiskBusy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_File_SetDiskBusy
  .p2align 4
  .type FMOD5_File_SetDiskBusy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_File_SetDiskBusy
#endif
FMOD5_File_SetDiskBusy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 784+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $196, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_File_SetDiskBusy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_AddPolygon
  .p2align 4
  .type FMOD5_Geometry_AddPolygon, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_AddPolygon
#endif
FMOD5_Geometry_AddPolygon:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 788+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $197, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_AddPolygon
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetActive
  .p2align 4
  .type FMOD5_Geometry_GetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetActive
#endif
FMOD5_Geometry_GetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 792+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $198, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetMaxPolygons
  .p2align 4
  .type FMOD5_Geometry_GetMaxPolygons, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetMaxPolygons
#endif
FMOD5_Geometry_GetMaxPolygons:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 796+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $199, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetMaxPolygons
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetNumPolygons
  .p2align 4
  .type FMOD5_Geometry_GetNumPolygons, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetNumPolygons
#endif
FMOD5_Geometry_GetNumPolygons:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 800+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $200, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetNumPolygons
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetPolygonAttributes
  .p2align 4
  .type FMOD5_Geometry_GetPolygonAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetPolygonAttributes
#endif
FMOD5_Geometry_GetPolygonAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 804+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $201, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetPolygonAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetPolygonNumVertices
  .p2align 4
  .type FMOD5_Geometry_GetPolygonNumVertices, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetPolygonNumVertices
#endif
FMOD5_Geometry_GetPolygonNumVertices:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 808+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $202, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetPolygonNumVertices
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetPolygonVertex
  .p2align 4
  .type FMOD5_Geometry_GetPolygonVertex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetPolygonVertex
#endif
FMOD5_Geometry_GetPolygonVertex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 812+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $203, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetPolygonVertex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetPosition
  .p2align 4
  .type FMOD5_Geometry_GetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetPosition
#endif
FMOD5_Geometry_GetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 816+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $204, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetRotation
  .p2align 4
  .type FMOD5_Geometry_GetRotation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetRotation
#endif
FMOD5_Geometry_GetRotation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 820+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $205, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetRotation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetScale
  .p2align 4
  .type FMOD5_Geometry_GetScale, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetScale
#endif
FMOD5_Geometry_GetScale:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 824+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $206, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetScale
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_GetUserData
  .p2align 4
  .type FMOD5_Geometry_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_GetUserData
#endif
FMOD5_Geometry_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 828+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $207, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_Release
  .p2align 4
  .type FMOD5_Geometry_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_Release
#endif
FMOD5_Geometry_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 832+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $208, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_Save
  .p2align 4
  .type FMOD5_Geometry_Save, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_Save
#endif
FMOD5_Geometry_Save:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 836+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $209, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_Save
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetActive
  .p2align 4
  .type FMOD5_Geometry_SetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetActive
#endif
FMOD5_Geometry_SetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 840+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $210, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetPolygonAttributes
  .p2align 4
  .type FMOD5_Geometry_SetPolygonAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetPolygonAttributes
#endif
FMOD5_Geometry_SetPolygonAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 844+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $211, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetPolygonAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetPolygonVertex
  .p2align 4
  .type FMOD5_Geometry_SetPolygonVertex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetPolygonVertex
#endif
FMOD5_Geometry_SetPolygonVertex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 848+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $212, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetPolygonVertex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetPosition
  .p2align 4
  .type FMOD5_Geometry_SetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetPosition
#endif
FMOD5_Geometry_SetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 852+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $213, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetRotation
  .p2align 4
  .type FMOD5_Geometry_SetRotation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetRotation
#endif
FMOD5_Geometry_SetRotation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 856+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $214, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetRotation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetScale
  .p2align 4
  .type FMOD5_Geometry_SetScale, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetScale
#endif
FMOD5_Geometry_SetScale:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 860+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $215, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetScale
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Geometry_SetUserData
  .p2align 4
  .type FMOD5_Geometry_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Geometry_SetUserData
#endif
FMOD5_Geometry_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 864+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $216, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Geometry_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Memory_GetStats
  .p2align 4
  .type FMOD5_Memory_GetStats, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Memory_GetStats
#endif
FMOD5_Memory_GetStats:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 868+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $217, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Memory_GetStats
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Memory_Initialize
  .p2align 4
  .type FMOD5_Memory_Initialize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Memory_Initialize
#endif
FMOD5_Memory_Initialize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 872+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $218, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Memory_Initialize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_Get3DAttributes
  .p2align 4
  .type FMOD5_Reverb3D_Get3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_Get3DAttributes
#endif
FMOD5_Reverb3D_Get3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 876+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $219, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_Get3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_GetActive
  .p2align 4
  .type FMOD5_Reverb3D_GetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_GetActive
#endif
FMOD5_Reverb3D_GetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 880+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $220, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_GetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_GetProperties
  .p2align 4
  .type FMOD5_Reverb3D_GetProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_GetProperties
#endif
FMOD5_Reverb3D_GetProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 884+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $221, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_GetProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_GetUserData
  .p2align 4
  .type FMOD5_Reverb3D_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_GetUserData
#endif
FMOD5_Reverb3D_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 888+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $222, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_Release
  .p2align 4
  .type FMOD5_Reverb3D_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_Release
#endif
FMOD5_Reverb3D_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 892+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $223, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_Set3DAttributes
  .p2align 4
  .type FMOD5_Reverb3D_Set3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_Set3DAttributes
#endif
FMOD5_Reverb3D_Set3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 896+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $224, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_Set3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_SetActive
  .p2align 4
  .type FMOD5_Reverb3D_SetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_SetActive
#endif
FMOD5_Reverb3D_SetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 900+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $225, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_SetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_SetProperties
  .p2align 4
  .type FMOD5_Reverb3D_SetProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_SetProperties
#endif
FMOD5_Reverb3D_SetProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 904+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $226, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_SetProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Reverb3D_SetUserData
  .p2align 4
  .type FMOD5_Reverb3D_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Reverb3D_SetUserData
#endif
FMOD5_Reverb3D_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 908+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $227, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Reverb3D_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetMaxAudible
  .p2align 4
  .type FMOD5_SoundGroup_GetMaxAudible, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetMaxAudible
#endif
FMOD5_SoundGroup_GetMaxAudible:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 912+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $228, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetMaxAudible
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetMaxAudibleBehavior
  .p2align 4
  .type FMOD5_SoundGroup_GetMaxAudibleBehavior, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetMaxAudibleBehavior
#endif
FMOD5_SoundGroup_GetMaxAudibleBehavior:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 916+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $229, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetMaxAudibleBehavior
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetMuteFadeSpeed
  .p2align 4
  .type FMOD5_SoundGroup_GetMuteFadeSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetMuteFadeSpeed
#endif
FMOD5_SoundGroup_GetMuteFadeSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 920+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $230, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetMuteFadeSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetName
  .p2align 4
  .type FMOD5_SoundGroup_GetName, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetName
#endif
FMOD5_SoundGroup_GetName:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 924+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $231, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetName
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetNumPlaying
  .p2align 4
  .type FMOD5_SoundGroup_GetNumPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetNumPlaying
#endif
FMOD5_SoundGroup_GetNumPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 928+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $232, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetNumPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetNumSounds
  .p2align 4
  .type FMOD5_SoundGroup_GetNumSounds, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetNumSounds
#endif
FMOD5_SoundGroup_GetNumSounds:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 932+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $233, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetNumSounds
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetSound
  .p2align 4
  .type FMOD5_SoundGroup_GetSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetSound
#endif
FMOD5_SoundGroup_GetSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 936+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $234, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetSystemObject
  .p2align 4
  .type FMOD5_SoundGroup_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetSystemObject
#endif
FMOD5_SoundGroup_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 940+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $235, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetUserData
  .p2align 4
  .type FMOD5_SoundGroup_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetUserData
#endif
FMOD5_SoundGroup_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 944+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $236, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_GetVolume
  .p2align 4
  .type FMOD5_SoundGroup_GetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_GetVolume
#endif
FMOD5_SoundGroup_GetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 948+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $237, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_GetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_Release
  .p2align 4
  .type FMOD5_SoundGroup_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_Release
#endif
FMOD5_SoundGroup_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 952+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $238, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_SetMaxAudible
  .p2align 4
  .type FMOD5_SoundGroup_SetMaxAudible, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_SetMaxAudible
#endif
FMOD5_SoundGroup_SetMaxAudible:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 956+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $239, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_SetMaxAudible
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_SetMaxAudibleBehavior
  .p2align 4
  .type FMOD5_SoundGroup_SetMaxAudibleBehavior, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_SetMaxAudibleBehavior
#endif
FMOD5_SoundGroup_SetMaxAudibleBehavior:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 960+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $240, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_SetMaxAudibleBehavior
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_SetMuteFadeSpeed
  .p2align 4
  .type FMOD5_SoundGroup_SetMuteFadeSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_SetMuteFadeSpeed
#endif
FMOD5_SoundGroup_SetMuteFadeSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 964+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $241, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_SetMuteFadeSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_SetUserData
  .p2align 4
  .type FMOD5_SoundGroup_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_SetUserData
#endif
FMOD5_SoundGroup_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 968+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $242, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_SetVolume
  .p2align 4
  .type FMOD5_SoundGroup_SetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_SetVolume
#endif
FMOD5_SoundGroup_SetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 972+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $243, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_SetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_SoundGroup_Stop
  .p2align 4
  .type FMOD5_SoundGroup_Stop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_SoundGroup_Stop
#endif
FMOD5_SoundGroup_Stop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 976+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $244, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_SoundGroup_Stop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_AddSyncPoint
  .p2align 4
  .type FMOD5_Sound_AddSyncPoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_AddSyncPoint
#endif
FMOD5_Sound_AddSyncPoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 980+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $245, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_AddSyncPoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_DeleteSyncPoint
  .p2align 4
  .type FMOD5_Sound_DeleteSyncPoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_DeleteSyncPoint
#endif
FMOD5_Sound_DeleteSyncPoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 984+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $246, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_DeleteSyncPoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Get3DConeSettings
  .p2align 4
  .type FMOD5_Sound_Get3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Get3DConeSettings
#endif
FMOD5_Sound_Get3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 988+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $247, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Get3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Get3DCustomRolloff
  .p2align 4
  .type FMOD5_Sound_Get3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Get3DCustomRolloff
#endif
FMOD5_Sound_Get3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 992+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $248, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Get3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Get3DMinMaxDistance
  .p2align 4
  .type FMOD5_Sound_Get3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Get3DMinMaxDistance
#endif
FMOD5_Sound_Get3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 996+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $249, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Get3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetDefaults
  .p2align 4
  .type FMOD5_Sound_GetDefaults, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetDefaults
#endif
FMOD5_Sound_GetDefaults:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1000+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $250, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetDefaults
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetFormat
  .p2align 4
  .type FMOD5_Sound_GetFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetFormat
#endif
FMOD5_Sound_GetFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1004+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $251, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetLength
  .p2align 4
  .type FMOD5_Sound_GetLength, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetLength
#endif
FMOD5_Sound_GetLength:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1008+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $252, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetLength
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetLoopCount
  .p2align 4
  .type FMOD5_Sound_GetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetLoopCount
#endif
FMOD5_Sound_GetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1012+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $253, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetLoopPoints
  .p2align 4
  .type FMOD5_Sound_GetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetLoopPoints
#endif
FMOD5_Sound_GetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1016+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $254, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetMode
  .p2align 4
  .type FMOD5_Sound_GetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetMode
#endif
FMOD5_Sound_GetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1020+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $255, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetMusicChannelVolume
  .p2align 4
  .type FMOD5_Sound_GetMusicChannelVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetMusicChannelVolume
#endif
FMOD5_Sound_GetMusicChannelVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1024+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $256, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetMusicChannelVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetMusicNumChannels
  .p2align 4
  .type FMOD5_Sound_GetMusicNumChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetMusicNumChannels
#endif
FMOD5_Sound_GetMusicNumChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1028+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $257, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetMusicNumChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetMusicSpeed
  .p2align 4
  .type FMOD5_Sound_GetMusicSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetMusicSpeed
#endif
FMOD5_Sound_GetMusicSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1032+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $258, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetMusicSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetName
  .p2align 4
  .type FMOD5_Sound_GetName, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetName
#endif
FMOD5_Sound_GetName:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1036+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $259, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetName
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetNumSubSounds
  .p2align 4
  .type FMOD5_Sound_GetNumSubSounds, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetNumSubSounds
#endif
FMOD5_Sound_GetNumSubSounds:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1040+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $260, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetNumSubSounds
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetNumSyncPoints
  .p2align 4
  .type FMOD5_Sound_GetNumSyncPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetNumSyncPoints
#endif
FMOD5_Sound_GetNumSyncPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1044+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $261, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetNumSyncPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetNumTags
  .p2align 4
  .type FMOD5_Sound_GetNumTags, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetNumTags
#endif
FMOD5_Sound_GetNumTags:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1048+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $262, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetNumTags
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetOpenState
  .p2align 4
  .type FMOD5_Sound_GetOpenState, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetOpenState
#endif
FMOD5_Sound_GetOpenState:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1052+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $263, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetOpenState
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetSoundGroup
  .p2align 4
  .type FMOD5_Sound_GetSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetSoundGroup
#endif
FMOD5_Sound_GetSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1056+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $264, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetSubSound
  .p2align 4
  .type FMOD5_Sound_GetSubSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetSubSound
#endif
FMOD5_Sound_GetSubSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1060+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $265, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetSubSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetSubSoundParent
  .p2align 4
  .type FMOD5_Sound_GetSubSoundParent, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetSubSoundParent
#endif
FMOD5_Sound_GetSubSoundParent:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1064+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $266, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetSubSoundParent
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetSyncPoint
  .p2align 4
  .type FMOD5_Sound_GetSyncPoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetSyncPoint
#endif
FMOD5_Sound_GetSyncPoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1068+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $267, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetSyncPoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetSyncPointInfo
  .p2align 4
  .type FMOD5_Sound_GetSyncPointInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetSyncPointInfo
#endif
FMOD5_Sound_GetSyncPointInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1072+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $268, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetSyncPointInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetSystemObject
  .p2align 4
  .type FMOD5_Sound_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetSystemObject
#endif
FMOD5_Sound_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1076+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $269, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetTag
  .p2align 4
  .type FMOD5_Sound_GetTag, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetTag
#endif
FMOD5_Sound_GetTag:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1080+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $270, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetTag
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_GetUserData
  .p2align 4
  .type FMOD5_Sound_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_GetUserData
#endif
FMOD5_Sound_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1084+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $271, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Lock
  .p2align 4
  .type FMOD5_Sound_Lock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Lock
#endif
FMOD5_Sound_Lock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1088+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $272, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Lock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_ReadData
  .p2align 4
  .type FMOD5_Sound_ReadData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_ReadData
#endif
FMOD5_Sound_ReadData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1092+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $273, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_ReadData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Release
  .p2align 4
  .type FMOD5_Sound_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Release
#endif
FMOD5_Sound_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1096+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $274, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SeekData
  .p2align 4
  .type FMOD5_Sound_SeekData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SeekData
#endif
FMOD5_Sound_SeekData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1100+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $275, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SeekData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Set3DConeSettings
  .p2align 4
  .type FMOD5_Sound_Set3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Set3DConeSettings
#endif
FMOD5_Sound_Set3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1104+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $276, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Set3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Set3DCustomRolloff
  .p2align 4
  .type FMOD5_Sound_Set3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Set3DCustomRolloff
#endif
FMOD5_Sound_Set3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1108+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $277, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Set3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Set3DMinMaxDistance
  .p2align 4
  .type FMOD5_Sound_Set3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Set3DMinMaxDistance
#endif
FMOD5_Sound_Set3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1112+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $278, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Set3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetDefaults
  .p2align 4
  .type FMOD5_Sound_SetDefaults, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetDefaults
#endif
FMOD5_Sound_SetDefaults:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1116+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $279, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetDefaults
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetLoopCount
  .p2align 4
  .type FMOD5_Sound_SetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetLoopCount
#endif
FMOD5_Sound_SetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1120+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $280, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetLoopPoints
  .p2align 4
  .type FMOD5_Sound_SetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetLoopPoints
#endif
FMOD5_Sound_SetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1124+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $281, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetMode
  .p2align 4
  .type FMOD5_Sound_SetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetMode
#endif
FMOD5_Sound_SetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1128+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $282, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetMusicChannelVolume
  .p2align 4
  .type FMOD5_Sound_SetMusicChannelVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetMusicChannelVolume
#endif
FMOD5_Sound_SetMusicChannelVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1132+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $283, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetMusicChannelVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetMusicSpeed
  .p2align 4
  .type FMOD5_Sound_SetMusicSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetMusicSpeed
#endif
FMOD5_Sound_SetMusicSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1136+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $284, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetMusicSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetSoundGroup
  .p2align 4
  .type FMOD5_Sound_SetSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetSoundGroup
#endif
FMOD5_Sound_SetSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1140+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $285, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_SetUserData
  .p2align 4
  .type FMOD5_Sound_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_SetUserData
#endif
FMOD5_Sound_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1144+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $286, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Sound_Unlock
  .p2align 4
  .type FMOD5_Sound_Unlock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Sound_Unlock
#endif
FMOD5_Sound_Unlock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1148+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $287, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Sound_Unlock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_AttachChannelGroupToPort
  .p2align 4
  .type FMOD5_System_AttachChannelGroupToPort, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_AttachChannelGroupToPort
#endif
FMOD5_System_AttachChannelGroupToPort:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1152+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $288, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_AttachChannelGroupToPort
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_AttachFileSystem
  .p2align 4
  .type FMOD5_System_AttachFileSystem, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_AttachFileSystem
#endif
FMOD5_System_AttachFileSystem:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1156+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $289, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_AttachFileSystem
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Close
  .p2align 4
  .type FMOD5_System_Close, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Close
#endif
FMOD5_System_Close:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1160+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $290, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Close
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Create
  .p2align 4
  .type FMOD5_System_Create, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Create
#endif
FMOD5_System_Create:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1164+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $291, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Create
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateChannelGroup
  .p2align 4
  .type FMOD5_System_CreateChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateChannelGroup
#endif
FMOD5_System_CreateChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1168+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $292, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateDSP
  .p2align 4
  .type FMOD5_System_CreateDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateDSP
#endif
FMOD5_System_CreateDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1172+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $293, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateDSPByPlugin
  .p2align 4
  .type FMOD5_System_CreateDSPByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateDSPByPlugin
#endif
FMOD5_System_CreateDSPByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1176+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $294, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateDSPByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateDSPByType
  .p2align 4
  .type FMOD5_System_CreateDSPByType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateDSPByType
#endif
FMOD5_System_CreateDSPByType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1180+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $295, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateDSPByType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateGeometry
  .p2align 4
  .type FMOD5_System_CreateGeometry, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateGeometry
#endif
FMOD5_System_CreateGeometry:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1184+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $296, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateGeometry
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateReverb3D
  .p2align 4
  .type FMOD5_System_CreateReverb3D, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateReverb3D
#endif
FMOD5_System_CreateReverb3D:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1188+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $297, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateReverb3D
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateSound
  .p2align 4
  .type FMOD5_System_CreateSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateSound
#endif
FMOD5_System_CreateSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1192+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $298, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateSoundGroup
  .p2align 4
  .type FMOD5_System_CreateSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateSoundGroup
#endif
FMOD5_System_CreateSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1196+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $299, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_CreateStream
  .p2align 4
  .type FMOD5_System_CreateStream, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_CreateStream
#endif
FMOD5_System_CreateStream:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1200+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $300, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_CreateStream
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_DetachChannelGroupFromPort
  .p2align 4
  .type FMOD5_System_DetachChannelGroupFromPort, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_DetachChannelGroupFromPort
#endif
FMOD5_System_DetachChannelGroupFromPort:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1204+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $301, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_DetachChannelGroupFromPort
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Get3DListenerAttributes
  .p2align 4
  .type FMOD5_System_Get3DListenerAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Get3DListenerAttributes
#endif
FMOD5_System_Get3DListenerAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1208+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $302, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Get3DListenerAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Get3DNumListeners
  .p2align 4
  .type FMOD5_System_Get3DNumListeners, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Get3DNumListeners
#endif
FMOD5_System_Get3DNumListeners:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1212+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $303, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Get3DNumListeners
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Get3DSettings
  .p2align 4
  .type FMOD5_System_Get3DSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Get3DSettings
#endif
FMOD5_System_Get3DSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1216+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $304, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Get3DSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetAdvancedSettings
  .p2align 4
  .type FMOD5_System_GetAdvancedSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetAdvancedSettings
#endif
FMOD5_System_GetAdvancedSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1220+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $305, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetAdvancedSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetCPUUsage
  .p2align 4
  .type FMOD5_System_GetCPUUsage, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetCPUUsage
#endif
FMOD5_System_GetCPUUsage:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1224+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $306, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetCPUUsage
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetChannel
  .p2align 4
  .type FMOD5_System_GetChannel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetChannel
#endif
FMOD5_System_GetChannel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1228+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $307, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetChannel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetChannelsPlaying
  .p2align 4
  .type FMOD5_System_GetChannelsPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetChannelsPlaying
#endif
FMOD5_System_GetChannelsPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1232+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $308, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetChannelsPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetDSPBufferSize
  .p2align 4
  .type FMOD5_System_GetDSPBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetDSPBufferSize
#endif
FMOD5_System_GetDSPBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1236+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $309, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetDSPBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetDSPInfoByPlugin
  .p2align 4
  .type FMOD5_System_GetDSPInfoByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetDSPInfoByPlugin
#endif
FMOD5_System_GetDSPInfoByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1240+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $310, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetDSPInfoByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetDSPInfoByType
  .p2align 4
  .type FMOD5_System_GetDSPInfoByType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetDSPInfoByType
#endif
FMOD5_System_GetDSPInfoByType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1244+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $311, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetDSPInfoByType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetDefaultMixMatrix
  .p2align 4
  .type FMOD5_System_GetDefaultMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetDefaultMixMatrix
#endif
FMOD5_System_GetDefaultMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1248+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $312, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetDefaultMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetDriver
  .p2align 4
  .type FMOD5_System_GetDriver, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetDriver
#endif
FMOD5_System_GetDriver:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1252+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $313, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetDriver
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetDriverInfo
  .p2align 4
  .type FMOD5_System_GetDriverInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetDriverInfo
#endif
FMOD5_System_GetDriverInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1256+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $314, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetDriverInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetFileUsage
  .p2align 4
  .type FMOD5_System_GetFileUsage, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetFileUsage
#endif
FMOD5_System_GetFileUsage:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1260+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $315, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetFileUsage
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetGeometryOcclusion
  .p2align 4
  .type FMOD5_System_GetGeometryOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetGeometryOcclusion
#endif
FMOD5_System_GetGeometryOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1264+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $316, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetGeometryOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetGeometrySettings
  .p2align 4
  .type FMOD5_System_GetGeometrySettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetGeometrySettings
#endif
FMOD5_System_GetGeometrySettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1268+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $317, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetGeometrySettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetMasterChannelGroup
  .p2align 4
  .type FMOD5_System_GetMasterChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetMasterChannelGroup
#endif
FMOD5_System_GetMasterChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1272+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $318, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetMasterChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetMasterSoundGroup
  .p2align 4
  .type FMOD5_System_GetMasterSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetMasterSoundGroup
#endif
FMOD5_System_GetMasterSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1276+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $319, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetMasterSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetNestedPlugin
  .p2align 4
  .type FMOD5_System_GetNestedPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetNestedPlugin
#endif
FMOD5_System_GetNestedPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1280+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $320, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetNestedPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetNetworkProxy
  .p2align 4
  .type FMOD5_System_GetNetworkProxy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetNetworkProxy
#endif
FMOD5_System_GetNetworkProxy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1284+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $321, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetNetworkProxy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetNetworkTimeout
  .p2align 4
  .type FMOD5_System_GetNetworkTimeout, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetNetworkTimeout
#endif
FMOD5_System_GetNetworkTimeout:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1288+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $322, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetNetworkTimeout
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetNumDrivers
  .p2align 4
  .type FMOD5_System_GetNumDrivers, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetNumDrivers
#endif
FMOD5_System_GetNumDrivers:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1292+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $323, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetNumDrivers
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetNumNestedPlugins
  .p2align 4
  .type FMOD5_System_GetNumNestedPlugins, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetNumNestedPlugins
#endif
FMOD5_System_GetNumNestedPlugins:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1296+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $324, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetNumNestedPlugins
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetNumPlugins
  .p2align 4
  .type FMOD5_System_GetNumPlugins, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetNumPlugins
#endif
FMOD5_System_GetNumPlugins:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1300+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $325, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetNumPlugins
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetOutput
  .p2align 4
  .type FMOD5_System_GetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetOutput
#endif
FMOD5_System_GetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1304+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $326, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetOutputByPlugin
  .p2align 4
  .type FMOD5_System_GetOutputByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetOutputByPlugin
#endif
FMOD5_System_GetOutputByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1308+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $327, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetOutputByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetOutputHandle
  .p2align 4
  .type FMOD5_System_GetOutputHandle, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetOutputHandle
#endif
FMOD5_System_GetOutputHandle:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1312+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $328, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetOutputHandle
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetPluginHandle
  .p2align 4
  .type FMOD5_System_GetPluginHandle, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetPluginHandle
#endif
FMOD5_System_GetPluginHandle:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1316+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $329, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetPluginHandle
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetPluginInfo
  .p2align 4
  .type FMOD5_System_GetPluginInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetPluginInfo
#endif
FMOD5_System_GetPluginInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1320+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $330, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetPluginInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetRecordDriverInfo
  .p2align 4
  .type FMOD5_System_GetRecordDriverInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetRecordDriverInfo
#endif
FMOD5_System_GetRecordDriverInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1324+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $331, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetRecordDriverInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetRecordNumDrivers
  .p2align 4
  .type FMOD5_System_GetRecordNumDrivers, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetRecordNumDrivers
#endif
FMOD5_System_GetRecordNumDrivers:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1328+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $332, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetRecordNumDrivers
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetRecordPosition
  .p2align 4
  .type FMOD5_System_GetRecordPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetRecordPosition
#endif
FMOD5_System_GetRecordPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1332+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $333, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetRecordPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetReverbProperties
  .p2align 4
  .type FMOD5_System_GetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetReverbProperties
#endif
FMOD5_System_GetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1336+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $334, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetSoftwareChannels
  .p2align 4
  .type FMOD5_System_GetSoftwareChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetSoftwareChannels
#endif
FMOD5_System_GetSoftwareChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1340+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $335, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetSoftwareChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetSoftwareFormat
  .p2align 4
  .type FMOD5_System_GetSoftwareFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetSoftwareFormat
#endif
FMOD5_System_GetSoftwareFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1344+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $336, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetSoftwareFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetSpeakerModeChannels
  .p2align 4
  .type FMOD5_System_GetSpeakerModeChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetSpeakerModeChannels
#endif
FMOD5_System_GetSpeakerModeChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1348+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $337, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetSpeakerModeChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetSpeakerPosition
  .p2align 4
  .type FMOD5_System_GetSpeakerPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetSpeakerPosition
#endif
FMOD5_System_GetSpeakerPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1352+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $338, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetSpeakerPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetStreamBufferSize
  .p2align 4
  .type FMOD5_System_GetStreamBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetStreamBufferSize
#endif
FMOD5_System_GetStreamBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1356+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $339, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetStreamBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetUserData
  .p2align 4
  .type FMOD5_System_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetUserData
#endif
FMOD5_System_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1360+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $340, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_GetVersion
  .p2align 4
  .type FMOD5_System_GetVersion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_GetVersion
#endif
FMOD5_System_GetVersion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1364+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $341, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_GetVersion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Init
  .p2align 4
  .type FMOD5_System_Init, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Init
#endif
FMOD5_System_Init:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1368+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $342, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Init
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_IsRecording
  .p2align 4
  .type FMOD5_System_IsRecording, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_IsRecording
#endif
FMOD5_System_IsRecording:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1372+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $343, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_IsRecording
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_LoadGeometry
  .p2align 4
  .type FMOD5_System_LoadGeometry, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_LoadGeometry
#endif
FMOD5_System_LoadGeometry:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1376+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $344, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_LoadGeometry
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_LoadPlugin
  .p2align 4
  .type FMOD5_System_LoadPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_LoadPlugin
#endif
FMOD5_System_LoadPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1380+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $345, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_LoadPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_LockDSP
  .p2align 4
  .type FMOD5_System_LockDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_LockDSP
#endif
FMOD5_System_LockDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1384+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $346, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_LockDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_MixerResume
  .p2align 4
  .type FMOD5_System_MixerResume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_MixerResume
#endif
FMOD5_System_MixerResume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1388+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $347, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_MixerResume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_MixerSuspend
  .p2align 4
  .type FMOD5_System_MixerSuspend, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_MixerSuspend
#endif
FMOD5_System_MixerSuspend:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1392+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $348, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_MixerSuspend
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_PlayDSP
  .p2align 4
  .type FMOD5_System_PlayDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_PlayDSP
#endif
FMOD5_System_PlayDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1396+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $349, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_PlayDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_PlaySound
  .p2align 4
  .type FMOD5_System_PlaySound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_PlaySound
#endif
FMOD5_System_PlaySound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1400+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $350, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_PlaySound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_RecordStart
  .p2align 4
  .type FMOD5_System_RecordStart, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_RecordStart
#endif
FMOD5_System_RecordStart:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1404+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $351, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_RecordStart
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_RecordStop
  .p2align 4
  .type FMOD5_System_RecordStop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_RecordStop
#endif
FMOD5_System_RecordStop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1408+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $352, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_RecordStop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_RegisterCodec
  .p2align 4
  .type FMOD5_System_RegisterCodec, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_RegisterCodec
#endif
FMOD5_System_RegisterCodec:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1412+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $353, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_RegisterCodec
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_RegisterDSP
  .p2align 4
  .type FMOD5_System_RegisterDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_RegisterDSP
#endif
FMOD5_System_RegisterDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1416+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $354, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_RegisterDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_RegisterOutput
  .p2align 4
  .type FMOD5_System_RegisterOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_RegisterOutput
#endif
FMOD5_System_RegisterOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1420+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $355, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_RegisterOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Release
  .p2align 4
  .type FMOD5_System_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Release
#endif
FMOD5_System_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1424+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $356, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Set3DListenerAttributes
  .p2align 4
  .type FMOD5_System_Set3DListenerAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Set3DListenerAttributes
#endif
FMOD5_System_Set3DListenerAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1428+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $357, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Set3DListenerAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Set3DNumListeners
  .p2align 4
  .type FMOD5_System_Set3DNumListeners, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Set3DNumListeners
#endif
FMOD5_System_Set3DNumListeners:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1432+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $358, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Set3DNumListeners
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Set3DRolloffCallback
  .p2align 4
  .type FMOD5_System_Set3DRolloffCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Set3DRolloffCallback
#endif
FMOD5_System_Set3DRolloffCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1436+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $359, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Set3DRolloffCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Set3DSettings
  .p2align 4
  .type FMOD5_System_Set3DSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Set3DSettings
#endif
FMOD5_System_Set3DSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1440+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $360, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Set3DSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetAdvancedSettings
  .p2align 4
  .type FMOD5_System_SetAdvancedSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetAdvancedSettings
#endif
FMOD5_System_SetAdvancedSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1444+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $361, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetAdvancedSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetCallback
  .p2align 4
  .type FMOD5_System_SetCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetCallback
#endif
FMOD5_System_SetCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1448+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $362, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetDSPBufferSize
  .p2align 4
  .type FMOD5_System_SetDSPBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetDSPBufferSize
#endif
FMOD5_System_SetDSPBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1452+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $363, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetDSPBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetDriver
  .p2align 4
  .type FMOD5_System_SetDriver, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetDriver
#endif
FMOD5_System_SetDriver:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1456+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $364, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetDriver
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetFileSystem
  .p2align 4
  .type FMOD5_System_SetFileSystem, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetFileSystem
#endif
FMOD5_System_SetFileSystem:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1460+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $365, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetFileSystem
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetGeometrySettings
  .p2align 4
  .type FMOD5_System_SetGeometrySettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetGeometrySettings
#endif
FMOD5_System_SetGeometrySettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1464+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $366, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetGeometrySettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetNetworkProxy
  .p2align 4
  .type FMOD5_System_SetNetworkProxy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetNetworkProxy
#endif
FMOD5_System_SetNetworkProxy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1468+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $367, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetNetworkProxy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetNetworkTimeout
  .p2align 4
  .type FMOD5_System_SetNetworkTimeout, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetNetworkTimeout
#endif
FMOD5_System_SetNetworkTimeout:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1472+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $368, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetNetworkTimeout
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetOutput
  .p2align 4
  .type FMOD5_System_SetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetOutput
#endif
FMOD5_System_SetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1476+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $369, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetOutputByPlugin
  .p2align 4
  .type FMOD5_System_SetOutputByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetOutputByPlugin
#endif
FMOD5_System_SetOutputByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1480+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $370, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetOutputByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetPluginPath
  .p2align 4
  .type FMOD5_System_SetPluginPath, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetPluginPath
#endif
FMOD5_System_SetPluginPath:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1484+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $371, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetPluginPath
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetReverbProperties
  .p2align 4
  .type FMOD5_System_SetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetReverbProperties
#endif
FMOD5_System_SetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1488+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $372, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetSoftwareChannels
  .p2align 4
  .type FMOD5_System_SetSoftwareChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetSoftwareChannels
#endif
FMOD5_System_SetSoftwareChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1492+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $373, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetSoftwareChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetSoftwareFormat
  .p2align 4
  .type FMOD5_System_SetSoftwareFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetSoftwareFormat
#endif
FMOD5_System_SetSoftwareFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1496+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $374, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetSoftwareFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetSpeakerPosition
  .p2align 4
  .type FMOD5_System_SetSpeakerPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetSpeakerPosition
#endif
FMOD5_System_SetSpeakerPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1500+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $375, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetSpeakerPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetStreamBufferSize
  .p2align 4
  .type FMOD5_System_SetStreamBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetStreamBufferSize
#endif
FMOD5_System_SetStreamBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1504+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $376, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetStreamBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_SetUserData
  .p2align 4
  .type FMOD5_System_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_SetUserData
#endif
FMOD5_System_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1508+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $377, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_UnloadPlugin
  .p2align 4
  .type FMOD5_System_UnloadPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_UnloadPlugin
#endif
FMOD5_System_UnloadPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1512+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $378, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_UnloadPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_UnlockDSP
  .p2align 4
  .type FMOD5_System_UnlockDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_UnlockDSP
#endif
FMOD5_System_UnlockDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1516+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $379, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_UnlockDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_System_Update
  .p2align 4
  .type FMOD5_System_Update, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_System_Update
#endif
FMOD5_System_Update:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1520+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $380, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_System_Update
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD5_Thread_SetAttributes
  .p2align 4
  .type FMOD5_Thread_SetAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD5_Thread_SetAttributes
#endif
FMOD5_Thread_SetAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1524+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $381, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD5_Thread_SetAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_AddDSP
  .p2align 4
  .type FMOD_ChannelGroup_AddDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_AddDSP
#endif
FMOD_ChannelGroup_AddDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1528+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $382, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_AddDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_AddFadePoint
  .p2align 4
  .type FMOD_ChannelGroup_AddFadePoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_AddFadePoint
#endif
FMOD_ChannelGroup_AddFadePoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1532+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $383, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_AddFadePoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_AddGroup
  .p2align 4
  .type FMOD_ChannelGroup_AddGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_AddGroup
#endif
FMOD_ChannelGroup_AddGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1536+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $384, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_AddGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DAttributes
  .p2align 4
  .type FMOD_ChannelGroup_Get3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DAttributes
#endif
FMOD_ChannelGroup_Get3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1540+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $385, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DConeOrientation
  .p2align 4
  .type FMOD_ChannelGroup_Get3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DConeOrientation
#endif
FMOD_ChannelGroup_Get3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1544+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $386, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DConeSettings
  .p2align 4
  .type FMOD_ChannelGroup_Get3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DConeSettings
#endif
FMOD_ChannelGroup_Get3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1548+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $387, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DCustomRolloff
  .p2align 4
  .type FMOD_ChannelGroup_Get3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DCustomRolloff
#endif
FMOD_ChannelGroup_Get3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1552+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $388, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DDistanceFilter
  .p2align 4
  .type FMOD_ChannelGroup_Get3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DDistanceFilter
#endif
FMOD_ChannelGroup_Get3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1556+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $389, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DDopplerLevel
  .p2align 4
  .type FMOD_ChannelGroup_Get3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DDopplerLevel
#endif
FMOD_ChannelGroup_Get3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1560+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $390, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DLevel
  .p2align 4
  .type FMOD_ChannelGroup_Get3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DLevel
#endif
FMOD_ChannelGroup_Get3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1564+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $391, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DMinMaxDistance
  .p2align 4
  .type FMOD_ChannelGroup_Get3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DMinMaxDistance
#endif
FMOD_ChannelGroup_Get3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1568+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $392, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DOcclusion
  .p2align 4
  .type FMOD_ChannelGroup_Get3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DOcclusion
#endif
FMOD_ChannelGroup_Get3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1572+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $393, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Get3DSpread
  .p2align 4
  .type FMOD_ChannelGroup_Get3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Get3DSpread
#endif
FMOD_ChannelGroup_Get3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1576+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $394, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Get3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetAudibility
  .p2align 4
  .type FMOD_ChannelGroup_GetAudibility, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetAudibility
#endif
FMOD_ChannelGroup_GetAudibility:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1580+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $395, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetAudibility
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetChannel
  .p2align 4
  .type FMOD_ChannelGroup_GetChannel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetChannel
#endif
FMOD_ChannelGroup_GetChannel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1584+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $396, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetChannel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetDSP
  .p2align 4
  .type FMOD_ChannelGroup_GetDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetDSP
#endif
FMOD_ChannelGroup_GetDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1588+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $397, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetDSPClock
  .p2align 4
  .type FMOD_ChannelGroup_GetDSPClock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetDSPClock
#endif
FMOD_ChannelGroup_GetDSPClock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1592+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $398, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetDSPClock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetDSPIndex
  .p2align 4
  .type FMOD_ChannelGroup_GetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetDSPIndex
#endif
FMOD_ChannelGroup_GetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1596+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $399, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetDelay
  .p2align 4
  .type FMOD_ChannelGroup_GetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetDelay
#endif
FMOD_ChannelGroup_GetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1600+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $400, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetFadePoints
  .p2align 4
  .type FMOD_ChannelGroup_GetFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetFadePoints
#endif
FMOD_ChannelGroup_GetFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1604+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $401, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetGroup
  .p2align 4
  .type FMOD_ChannelGroup_GetGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetGroup
#endif
FMOD_ChannelGroup_GetGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1608+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $402, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetLowPassGain
  .p2align 4
  .type FMOD_ChannelGroup_GetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetLowPassGain
#endif
FMOD_ChannelGroup_GetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1612+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $403, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetMixMatrix
  .p2align 4
  .type FMOD_ChannelGroup_GetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetMixMatrix
#endif
FMOD_ChannelGroup_GetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1616+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $404, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetMode
  .p2align 4
  .type FMOD_ChannelGroup_GetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetMode
#endif
FMOD_ChannelGroup_GetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1620+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $405, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetMute
  .p2align 4
  .type FMOD_ChannelGroup_GetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetMute
#endif
FMOD_ChannelGroup_GetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1624+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $406, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetName
  .p2align 4
  .type FMOD_ChannelGroup_GetName, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetName
#endif
FMOD_ChannelGroup_GetName:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1628+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $407, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetName
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetNumChannels
  .p2align 4
  .type FMOD_ChannelGroup_GetNumChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetNumChannels
#endif
FMOD_ChannelGroup_GetNumChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1632+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $408, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetNumChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetNumDSPs
  .p2align 4
  .type FMOD_ChannelGroup_GetNumDSPs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetNumDSPs
#endif
FMOD_ChannelGroup_GetNumDSPs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1636+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $409, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetNumDSPs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetNumGroups
  .p2align 4
  .type FMOD_ChannelGroup_GetNumGroups, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetNumGroups
#endif
FMOD_ChannelGroup_GetNumGroups:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1640+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $410, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetNumGroups
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetParentGroup
  .p2align 4
  .type FMOD_ChannelGroup_GetParentGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetParentGroup
#endif
FMOD_ChannelGroup_GetParentGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1644+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $411, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetParentGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetPaused
  .p2align 4
  .type FMOD_ChannelGroup_GetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetPaused
#endif
FMOD_ChannelGroup_GetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1648+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $412, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetPitch
  .p2align 4
  .type FMOD_ChannelGroup_GetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetPitch
#endif
FMOD_ChannelGroup_GetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1652+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $413, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetReverbProperties
  .p2align 4
  .type FMOD_ChannelGroup_GetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetReverbProperties
#endif
FMOD_ChannelGroup_GetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1656+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $414, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetSystemObject
  .p2align 4
  .type FMOD_ChannelGroup_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetSystemObject
#endif
FMOD_ChannelGroup_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1660+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $415, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetUserData
  .p2align 4
  .type FMOD_ChannelGroup_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetUserData
#endif
FMOD_ChannelGroup_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1664+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $416, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetVolume
  .p2align 4
  .type FMOD_ChannelGroup_GetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetVolume
#endif
FMOD_ChannelGroup_GetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1668+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $417, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_GetVolumeRamp
  .p2align 4
  .type FMOD_ChannelGroup_GetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_GetVolumeRamp
#endif
FMOD_ChannelGroup_GetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1672+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $418, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_GetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_IsPlaying
  .p2align 4
  .type FMOD_ChannelGroup_IsPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_IsPlaying
#endif
FMOD_ChannelGroup_IsPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1676+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $419, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_IsPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Release
  .p2align 4
  .type FMOD_ChannelGroup_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Release
#endif
FMOD_ChannelGroup_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1680+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $420, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_RemoveDSP
  .p2align 4
  .type FMOD_ChannelGroup_RemoveDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_RemoveDSP
#endif
FMOD_ChannelGroup_RemoveDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1684+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $421, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_RemoveDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_RemoveFadePoints
  .p2align 4
  .type FMOD_ChannelGroup_RemoveFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_RemoveFadePoints
#endif
FMOD_ChannelGroup_RemoveFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1688+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $422, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_RemoveFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DAttributes
  .p2align 4
  .type FMOD_ChannelGroup_Set3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DAttributes
#endif
FMOD_ChannelGroup_Set3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1692+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $423, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DConeOrientation
  .p2align 4
  .type FMOD_ChannelGroup_Set3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DConeOrientation
#endif
FMOD_ChannelGroup_Set3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1696+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $424, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DConeSettings
  .p2align 4
  .type FMOD_ChannelGroup_Set3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DConeSettings
#endif
FMOD_ChannelGroup_Set3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1700+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $425, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DCustomRolloff
  .p2align 4
  .type FMOD_ChannelGroup_Set3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DCustomRolloff
#endif
FMOD_ChannelGroup_Set3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1704+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $426, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DDistanceFilter
  .p2align 4
  .type FMOD_ChannelGroup_Set3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DDistanceFilter
#endif
FMOD_ChannelGroup_Set3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1708+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $427, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DDopplerLevel
  .p2align 4
  .type FMOD_ChannelGroup_Set3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DDopplerLevel
#endif
FMOD_ChannelGroup_Set3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1712+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $428, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DLevel
  .p2align 4
  .type FMOD_ChannelGroup_Set3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DLevel
#endif
FMOD_ChannelGroup_Set3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1716+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $429, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DMinMaxDistance
  .p2align 4
  .type FMOD_ChannelGroup_Set3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DMinMaxDistance
#endif
FMOD_ChannelGroup_Set3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1720+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $430, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DOcclusion
  .p2align 4
  .type FMOD_ChannelGroup_Set3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DOcclusion
#endif
FMOD_ChannelGroup_Set3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1724+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $431, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Set3DSpread
  .p2align 4
  .type FMOD_ChannelGroup_Set3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Set3DSpread
#endif
FMOD_ChannelGroup_Set3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1728+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $432, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Set3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetCallback
  .p2align 4
  .type FMOD_ChannelGroup_SetCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetCallback
#endif
FMOD_ChannelGroup_SetCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1732+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $433, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetDSPIndex
  .p2align 4
  .type FMOD_ChannelGroup_SetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetDSPIndex
#endif
FMOD_ChannelGroup_SetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1736+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $434, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetDelay
  .p2align 4
  .type FMOD_ChannelGroup_SetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetDelay
#endif
FMOD_ChannelGroup_SetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1740+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $435, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetFadePointRamp
  .p2align 4
  .type FMOD_ChannelGroup_SetFadePointRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetFadePointRamp
#endif
FMOD_ChannelGroup_SetFadePointRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1744+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $436, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetFadePointRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetLowPassGain
  .p2align 4
  .type FMOD_ChannelGroup_SetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetLowPassGain
#endif
FMOD_ChannelGroup_SetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1748+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $437, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetMixLevelsInput
  .p2align 4
  .type FMOD_ChannelGroup_SetMixLevelsInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetMixLevelsInput
#endif
FMOD_ChannelGroup_SetMixLevelsInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1752+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $438, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetMixLevelsInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetMixLevelsOutput
  .p2align 4
  .type FMOD_ChannelGroup_SetMixLevelsOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetMixLevelsOutput
#endif
FMOD_ChannelGroup_SetMixLevelsOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1756+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $439, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetMixLevelsOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetMixMatrix
  .p2align 4
  .type FMOD_ChannelGroup_SetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetMixMatrix
#endif
FMOD_ChannelGroup_SetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1760+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $440, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetMode
  .p2align 4
  .type FMOD_ChannelGroup_SetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetMode
#endif
FMOD_ChannelGroup_SetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1764+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $441, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetMute
  .p2align 4
  .type FMOD_ChannelGroup_SetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetMute
#endif
FMOD_ChannelGroup_SetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1768+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $442, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetPan
  .p2align 4
  .type FMOD_ChannelGroup_SetPan, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetPan
#endif
FMOD_ChannelGroup_SetPan:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1772+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $443, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetPan
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetPaused
  .p2align 4
  .type FMOD_ChannelGroup_SetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetPaused
#endif
FMOD_ChannelGroup_SetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1776+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $444, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetPitch
  .p2align 4
  .type FMOD_ChannelGroup_SetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetPitch
#endif
FMOD_ChannelGroup_SetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1780+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $445, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetReverbProperties
  .p2align 4
  .type FMOD_ChannelGroup_SetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetReverbProperties
#endif
FMOD_ChannelGroup_SetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1784+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $446, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetUserData
  .p2align 4
  .type FMOD_ChannelGroup_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetUserData
#endif
FMOD_ChannelGroup_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1788+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $447, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetVolume
  .p2align 4
  .type FMOD_ChannelGroup_SetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetVolume
#endif
FMOD_ChannelGroup_SetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1792+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $448, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_SetVolumeRamp
  .p2align 4
  .type FMOD_ChannelGroup_SetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_SetVolumeRamp
#endif
FMOD_ChannelGroup_SetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1796+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $449, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_SetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_ChannelGroup_Stop
  .p2align 4
  .type FMOD_ChannelGroup_Stop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_ChannelGroup_Stop
#endif
FMOD_ChannelGroup_Stop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1800+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $450, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_ChannelGroup_Stop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_AddDSP
  .p2align 4
  .type FMOD_Channel_AddDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_AddDSP
#endif
FMOD_Channel_AddDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1804+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $451, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_AddDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_AddFadePoint
  .p2align 4
  .type FMOD_Channel_AddFadePoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_AddFadePoint
#endif
FMOD_Channel_AddFadePoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1808+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $452, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_AddFadePoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DAttributes
  .p2align 4
  .type FMOD_Channel_Get3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DAttributes
#endif
FMOD_Channel_Get3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1812+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $453, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DConeOrientation
  .p2align 4
  .type FMOD_Channel_Get3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DConeOrientation
#endif
FMOD_Channel_Get3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1816+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $454, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DConeSettings
  .p2align 4
  .type FMOD_Channel_Get3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DConeSettings
#endif
FMOD_Channel_Get3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1820+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $455, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DCustomRolloff
  .p2align 4
  .type FMOD_Channel_Get3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DCustomRolloff
#endif
FMOD_Channel_Get3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1824+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $456, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DDistanceFilter
  .p2align 4
  .type FMOD_Channel_Get3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DDistanceFilter
#endif
FMOD_Channel_Get3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1828+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $457, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DDopplerLevel
  .p2align 4
  .type FMOD_Channel_Get3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DDopplerLevel
#endif
FMOD_Channel_Get3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1832+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $458, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DLevel
  .p2align 4
  .type FMOD_Channel_Get3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DLevel
#endif
FMOD_Channel_Get3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1836+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $459, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DMinMaxDistance
  .p2align 4
  .type FMOD_Channel_Get3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DMinMaxDistance
#endif
FMOD_Channel_Get3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1840+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $460, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DOcclusion
  .p2align 4
  .type FMOD_Channel_Get3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DOcclusion
#endif
FMOD_Channel_Get3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1844+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $461, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Get3DSpread
  .p2align 4
  .type FMOD_Channel_Get3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Get3DSpread
#endif
FMOD_Channel_Get3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1848+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $462, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Get3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetAudibility
  .p2align 4
  .type FMOD_Channel_GetAudibility, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetAudibility
#endif
FMOD_Channel_GetAudibility:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1852+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $463, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetAudibility
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetChannelGroup
  .p2align 4
  .type FMOD_Channel_GetChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetChannelGroup
#endif
FMOD_Channel_GetChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1856+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $464, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetCurrentSound
  .p2align 4
  .type FMOD_Channel_GetCurrentSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetCurrentSound
#endif
FMOD_Channel_GetCurrentSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1860+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $465, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetCurrentSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetDSP
  .p2align 4
  .type FMOD_Channel_GetDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetDSP
#endif
FMOD_Channel_GetDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1864+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $466, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetDSPClock
  .p2align 4
  .type FMOD_Channel_GetDSPClock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetDSPClock
#endif
FMOD_Channel_GetDSPClock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1868+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $467, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetDSPClock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetDSPIndex
  .p2align 4
  .type FMOD_Channel_GetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetDSPIndex
#endif
FMOD_Channel_GetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1872+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $468, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetDelay
  .p2align 4
  .type FMOD_Channel_GetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetDelay
#endif
FMOD_Channel_GetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1876+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $469, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetFadePoints
  .p2align 4
  .type FMOD_Channel_GetFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetFadePoints
#endif
FMOD_Channel_GetFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1880+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $470, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetFrequency
  .p2align 4
  .type FMOD_Channel_GetFrequency, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetFrequency
#endif
FMOD_Channel_GetFrequency:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1884+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $471, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetFrequency
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetIndex
  .p2align 4
  .type FMOD_Channel_GetIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetIndex
#endif
FMOD_Channel_GetIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1888+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $472, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetLoopCount
  .p2align 4
  .type FMOD_Channel_GetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetLoopCount
#endif
FMOD_Channel_GetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1892+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $473, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetLoopPoints
  .p2align 4
  .type FMOD_Channel_GetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetLoopPoints
#endif
FMOD_Channel_GetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1896+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $474, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetLowPassGain
  .p2align 4
  .type FMOD_Channel_GetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetLowPassGain
#endif
FMOD_Channel_GetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1900+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $475, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetMixMatrix
  .p2align 4
  .type FMOD_Channel_GetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetMixMatrix
#endif
FMOD_Channel_GetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1904+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $476, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetMode
  .p2align 4
  .type FMOD_Channel_GetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetMode
#endif
FMOD_Channel_GetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1908+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $477, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetMute
  .p2align 4
  .type FMOD_Channel_GetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetMute
#endif
FMOD_Channel_GetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1912+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $478, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetNumDSPs
  .p2align 4
  .type FMOD_Channel_GetNumDSPs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetNumDSPs
#endif
FMOD_Channel_GetNumDSPs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1916+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $479, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetNumDSPs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetPaused
  .p2align 4
  .type FMOD_Channel_GetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetPaused
#endif
FMOD_Channel_GetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1920+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $480, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetPitch
  .p2align 4
  .type FMOD_Channel_GetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetPitch
#endif
FMOD_Channel_GetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1924+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $481, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetPosition
  .p2align 4
  .type FMOD_Channel_GetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetPosition
#endif
FMOD_Channel_GetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1928+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $482, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetPriority
  .p2align 4
  .type FMOD_Channel_GetPriority, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetPriority
#endif
FMOD_Channel_GetPriority:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1932+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $483, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetPriority
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetReverbProperties
  .p2align 4
  .type FMOD_Channel_GetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetReverbProperties
#endif
FMOD_Channel_GetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1936+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $484, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetSystemObject
  .p2align 4
  .type FMOD_Channel_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetSystemObject
#endif
FMOD_Channel_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1940+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $485, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetUserData
  .p2align 4
  .type FMOD_Channel_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetUserData
#endif
FMOD_Channel_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1944+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $486, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetVolume
  .p2align 4
  .type FMOD_Channel_GetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetVolume
#endif
FMOD_Channel_GetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1948+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $487, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_GetVolumeRamp
  .p2align 4
  .type FMOD_Channel_GetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_GetVolumeRamp
#endif
FMOD_Channel_GetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1952+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $488, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_GetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_IsPlaying
  .p2align 4
  .type FMOD_Channel_IsPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_IsPlaying
#endif
FMOD_Channel_IsPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1956+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $489, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_IsPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_IsVirtual
  .p2align 4
  .type FMOD_Channel_IsVirtual, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_IsVirtual
#endif
FMOD_Channel_IsVirtual:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1960+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $490, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_IsVirtual
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_RemoveDSP
  .p2align 4
  .type FMOD_Channel_RemoveDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_RemoveDSP
#endif
FMOD_Channel_RemoveDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1964+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $491, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_RemoveDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_RemoveFadePoints
  .p2align 4
  .type FMOD_Channel_RemoveFadePoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_RemoveFadePoints
#endif
FMOD_Channel_RemoveFadePoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1968+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $492, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_RemoveFadePoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DAttributes
  .p2align 4
  .type FMOD_Channel_Set3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DAttributes
#endif
FMOD_Channel_Set3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1972+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $493, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DConeOrientation
  .p2align 4
  .type FMOD_Channel_Set3DConeOrientation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DConeOrientation
#endif
FMOD_Channel_Set3DConeOrientation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1976+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $494, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DConeOrientation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DConeSettings
  .p2align 4
  .type FMOD_Channel_Set3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DConeSettings
#endif
FMOD_Channel_Set3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1980+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $495, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DCustomRolloff
  .p2align 4
  .type FMOD_Channel_Set3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DCustomRolloff
#endif
FMOD_Channel_Set3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1984+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $496, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DDistanceFilter
  .p2align 4
  .type FMOD_Channel_Set3DDistanceFilter, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DDistanceFilter
#endif
FMOD_Channel_Set3DDistanceFilter:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1988+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $497, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DDistanceFilter
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DDopplerLevel
  .p2align 4
  .type FMOD_Channel_Set3DDopplerLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DDopplerLevel
#endif
FMOD_Channel_Set3DDopplerLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1992+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $498, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DDopplerLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DLevel
  .p2align 4
  .type FMOD_Channel_Set3DLevel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DLevel
#endif
FMOD_Channel_Set3DLevel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 1996+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $499, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DLevel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DMinMaxDistance
  .p2align 4
  .type FMOD_Channel_Set3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DMinMaxDistance
#endif
FMOD_Channel_Set3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2000+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $500, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DOcclusion
  .p2align 4
  .type FMOD_Channel_Set3DOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DOcclusion
#endif
FMOD_Channel_Set3DOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2004+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $501, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Set3DSpread
  .p2align 4
  .type FMOD_Channel_Set3DSpread, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Set3DSpread
#endif
FMOD_Channel_Set3DSpread:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2008+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $502, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Set3DSpread
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetCallback
  .p2align 4
  .type FMOD_Channel_SetCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetCallback
#endif
FMOD_Channel_SetCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2012+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $503, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetChannelGroup
  .p2align 4
  .type FMOD_Channel_SetChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetChannelGroup
#endif
FMOD_Channel_SetChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2016+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $504, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetDSPIndex
  .p2align 4
  .type FMOD_Channel_SetDSPIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetDSPIndex
#endif
FMOD_Channel_SetDSPIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2020+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $505, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetDSPIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetDelay
  .p2align 4
  .type FMOD_Channel_SetDelay, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetDelay
#endif
FMOD_Channel_SetDelay:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2024+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $506, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetDelay
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetFadePointRamp
  .p2align 4
  .type FMOD_Channel_SetFadePointRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetFadePointRamp
#endif
FMOD_Channel_SetFadePointRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2028+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $507, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetFadePointRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetFrequency
  .p2align 4
  .type FMOD_Channel_SetFrequency, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetFrequency
#endif
FMOD_Channel_SetFrequency:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2032+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $508, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetFrequency
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetLoopCount
  .p2align 4
  .type FMOD_Channel_SetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetLoopCount
#endif
FMOD_Channel_SetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2036+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $509, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetLoopPoints
  .p2align 4
  .type FMOD_Channel_SetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetLoopPoints
#endif
FMOD_Channel_SetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2040+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $510, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetLowPassGain
  .p2align 4
  .type FMOD_Channel_SetLowPassGain, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetLowPassGain
#endif
FMOD_Channel_SetLowPassGain:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2044+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $511, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetLowPassGain
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetMixLevelsInput
  .p2align 4
  .type FMOD_Channel_SetMixLevelsInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetMixLevelsInput
#endif
FMOD_Channel_SetMixLevelsInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2048+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $512, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetMixLevelsInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetMixLevelsOutput
  .p2align 4
  .type FMOD_Channel_SetMixLevelsOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetMixLevelsOutput
#endif
FMOD_Channel_SetMixLevelsOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2052+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $513, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetMixLevelsOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetMixMatrix
  .p2align 4
  .type FMOD_Channel_SetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetMixMatrix
#endif
FMOD_Channel_SetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2056+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $514, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetMode
  .p2align 4
  .type FMOD_Channel_SetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetMode
#endif
FMOD_Channel_SetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2060+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $515, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetMute
  .p2align 4
  .type FMOD_Channel_SetMute, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetMute
#endif
FMOD_Channel_SetMute:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2064+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $516, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetMute
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetPan
  .p2align 4
  .type FMOD_Channel_SetPan, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetPan
#endif
FMOD_Channel_SetPan:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2068+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $517, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetPan
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetPaused
  .p2align 4
  .type FMOD_Channel_SetPaused, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetPaused
#endif
FMOD_Channel_SetPaused:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2072+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $518, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetPaused
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetPitch
  .p2align 4
  .type FMOD_Channel_SetPitch, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetPitch
#endif
FMOD_Channel_SetPitch:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2076+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $519, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetPitch
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetPosition
  .p2align 4
  .type FMOD_Channel_SetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetPosition
#endif
FMOD_Channel_SetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2080+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $520, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetPriority
  .p2align 4
  .type FMOD_Channel_SetPriority, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetPriority
#endif
FMOD_Channel_SetPriority:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2084+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $521, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetPriority
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetReverbProperties
  .p2align 4
  .type FMOD_Channel_SetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetReverbProperties
#endif
FMOD_Channel_SetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2088+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $522, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetUserData
  .p2align 4
  .type FMOD_Channel_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetUserData
#endif
FMOD_Channel_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2092+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $523, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetVolume
  .p2align 4
  .type FMOD_Channel_SetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetVolume
#endif
FMOD_Channel_SetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2096+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $524, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_SetVolumeRamp
  .p2align 4
  .type FMOD_Channel_SetVolumeRamp, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_SetVolumeRamp
#endif
FMOD_Channel_SetVolumeRamp:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2100+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $525, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_SetVolumeRamp
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Channel_Stop
  .p2align 4
  .type FMOD_Channel_Stop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Channel_Stop
#endif
FMOD_Channel_Stop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2104+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $526, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Channel_Stop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_GetInput
  .p2align 4
  .type FMOD_DSPConnection_GetInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_GetInput
#endif
FMOD_DSPConnection_GetInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2108+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $527, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_GetInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_GetMix
  .p2align 4
  .type FMOD_DSPConnection_GetMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_GetMix
#endif
FMOD_DSPConnection_GetMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2112+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $528, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_GetMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_GetMixMatrix
  .p2align 4
  .type FMOD_DSPConnection_GetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_GetMixMatrix
#endif
FMOD_DSPConnection_GetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2116+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $529, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_GetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_GetOutput
  .p2align 4
  .type FMOD_DSPConnection_GetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_GetOutput
#endif
FMOD_DSPConnection_GetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2120+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $530, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_GetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_GetType
  .p2align 4
  .type FMOD_DSPConnection_GetType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_GetType
#endif
FMOD_DSPConnection_GetType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2124+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $531, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_GetType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_GetUserData
  .p2align 4
  .type FMOD_DSPConnection_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_GetUserData
#endif
FMOD_DSPConnection_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2128+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $532, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_SetMix
  .p2align 4
  .type FMOD_DSPConnection_SetMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_SetMix
#endif
FMOD_DSPConnection_SetMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2132+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $533, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_SetMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_SetMixMatrix
  .p2align 4
  .type FMOD_DSPConnection_SetMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_SetMixMatrix
#endif
FMOD_DSPConnection_SetMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2136+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $534, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_SetMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSPConnection_SetUserData
  .p2align 4
  .type FMOD_DSPConnection_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSPConnection_SetUserData
#endif
FMOD_DSPConnection_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2140+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $535, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSPConnection_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_AddInput
  .p2align 4
  .type FMOD_DSP_AddInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_AddInput
#endif
FMOD_DSP_AddInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2144+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $536, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_AddInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_DisconnectAll
  .p2align 4
  .type FMOD_DSP_DisconnectAll, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_DisconnectAll
#endif
FMOD_DSP_DisconnectAll:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2148+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $537, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_DisconnectAll
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_DisconnectFrom
  .p2align 4
  .type FMOD_DSP_DisconnectFrom, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_DisconnectFrom
#endif
FMOD_DSP_DisconnectFrom:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2152+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $538, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_DisconnectFrom
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetActive
  .p2align 4
  .type FMOD_DSP_GetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetActive
#endif
FMOD_DSP_GetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2156+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $539, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetBypass
  .p2align 4
  .type FMOD_DSP_GetBypass, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetBypass
#endif
FMOD_DSP_GetBypass:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2160+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $540, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetBypass
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetCPUUsage
  .p2align 4
  .type FMOD_DSP_GetCPUUsage, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetCPUUsage
#endif
FMOD_DSP_GetCPUUsage:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2164+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $541, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetCPUUsage
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetChannelFormat
  .p2align 4
  .type FMOD_DSP_GetChannelFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetChannelFormat
#endif
FMOD_DSP_GetChannelFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2168+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $542, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetChannelFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetDataParameterIndex
  .p2align 4
  .type FMOD_DSP_GetDataParameterIndex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetDataParameterIndex
#endif
FMOD_DSP_GetDataParameterIndex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2172+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $543, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetDataParameterIndex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetIdle
  .p2align 4
  .type FMOD_DSP_GetIdle, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetIdle
#endif
FMOD_DSP_GetIdle:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2176+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $544, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetIdle
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetInfo
  .p2align 4
  .type FMOD_DSP_GetInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetInfo
#endif
FMOD_DSP_GetInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2180+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $545, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetInput
  .p2align 4
  .type FMOD_DSP_GetInput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetInput
#endif
FMOD_DSP_GetInput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2184+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $546, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetInput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetMeteringEnabled
  .p2align 4
  .type FMOD_DSP_GetMeteringEnabled, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetMeteringEnabled
#endif
FMOD_DSP_GetMeteringEnabled:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2188+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $547, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetMeteringEnabled
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetMeteringInfo
  .p2align 4
  .type FMOD_DSP_GetMeteringInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetMeteringInfo
#endif
FMOD_DSP_GetMeteringInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2192+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $548, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetMeteringInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetNumInputs
  .p2align 4
  .type FMOD_DSP_GetNumInputs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetNumInputs
#endif
FMOD_DSP_GetNumInputs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2196+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $549, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetNumInputs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetNumOutputs
  .p2align 4
  .type FMOD_DSP_GetNumOutputs, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetNumOutputs
#endif
FMOD_DSP_GetNumOutputs:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2200+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $550, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetNumOutputs
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetNumParameters
  .p2align 4
  .type FMOD_DSP_GetNumParameters, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetNumParameters
#endif
FMOD_DSP_GetNumParameters:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2204+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $551, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetNumParameters
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetOutput
  .p2align 4
  .type FMOD_DSP_GetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetOutput
#endif
FMOD_DSP_GetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2208+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $552, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetOutputChannelFormat
  .p2align 4
  .type FMOD_DSP_GetOutputChannelFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetOutputChannelFormat
#endif
FMOD_DSP_GetOutputChannelFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2212+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $553, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetOutputChannelFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetParameterBool
  .p2align 4
  .type FMOD_DSP_GetParameterBool, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetParameterBool
#endif
FMOD_DSP_GetParameterBool:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2216+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $554, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetParameterBool
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetParameterData
  .p2align 4
  .type FMOD_DSP_GetParameterData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetParameterData
#endif
FMOD_DSP_GetParameterData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2220+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $555, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetParameterData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetParameterFloat
  .p2align 4
  .type FMOD_DSP_GetParameterFloat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetParameterFloat
#endif
FMOD_DSP_GetParameterFloat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2224+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $556, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetParameterFloat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetParameterInfo
  .p2align 4
  .type FMOD_DSP_GetParameterInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetParameterInfo
#endif
FMOD_DSP_GetParameterInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2228+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $557, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetParameterInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetParameterInt
  .p2align 4
  .type FMOD_DSP_GetParameterInt, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetParameterInt
#endif
FMOD_DSP_GetParameterInt:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2232+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $558, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetParameterInt
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetSystemObject
  .p2align 4
  .type FMOD_DSP_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetSystemObject
#endif
FMOD_DSP_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2236+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $559, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetType
  .p2align 4
  .type FMOD_DSP_GetType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetType
#endif
FMOD_DSP_GetType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2240+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $560, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetUserData
  .p2align 4
  .type FMOD_DSP_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetUserData
#endif
FMOD_DSP_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2244+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $561, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_GetWetDryMix
  .p2align 4
  .type FMOD_DSP_GetWetDryMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_GetWetDryMix
#endif
FMOD_DSP_GetWetDryMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2248+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $562, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_GetWetDryMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_Release
  .p2align 4
  .type FMOD_DSP_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_Release
#endif
FMOD_DSP_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2252+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $563, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_Reset
  .p2align 4
  .type FMOD_DSP_Reset, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_Reset
#endif
FMOD_DSP_Reset:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2256+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $564, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_Reset
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetActive
  .p2align 4
  .type FMOD_DSP_SetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetActive
#endif
FMOD_DSP_SetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2260+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $565, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetBypass
  .p2align 4
  .type FMOD_DSP_SetBypass, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetBypass
#endif
FMOD_DSP_SetBypass:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2264+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $566, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetBypass
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetChannelFormat
  .p2align 4
  .type FMOD_DSP_SetChannelFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetChannelFormat
#endif
FMOD_DSP_SetChannelFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2268+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $567, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetChannelFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetMeteringEnabled
  .p2align 4
  .type FMOD_DSP_SetMeteringEnabled, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetMeteringEnabled
#endif
FMOD_DSP_SetMeteringEnabled:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2272+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $568, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetMeteringEnabled
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetParameterBool
  .p2align 4
  .type FMOD_DSP_SetParameterBool, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetParameterBool
#endif
FMOD_DSP_SetParameterBool:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2276+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $569, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetParameterBool
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetParameterData
  .p2align 4
  .type FMOD_DSP_SetParameterData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetParameterData
#endif
FMOD_DSP_SetParameterData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2280+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $570, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetParameterData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetParameterFloat
  .p2align 4
  .type FMOD_DSP_SetParameterFloat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetParameterFloat
#endif
FMOD_DSP_SetParameterFloat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2284+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $571, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetParameterFloat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetParameterInt
  .p2align 4
  .type FMOD_DSP_SetParameterInt, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetParameterInt
#endif
FMOD_DSP_SetParameterInt:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2288+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $572, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetParameterInt
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetUserData
  .p2align 4
  .type FMOD_DSP_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetUserData
#endif
FMOD_DSP_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2292+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $573, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_SetWetDryMix
  .p2align 4
  .type FMOD_DSP_SetWetDryMix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_SetWetDryMix
#endif
FMOD_DSP_SetWetDryMix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2296+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $574, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_SetWetDryMix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_DSP_ShowConfigDialog
  .p2align 4
  .type FMOD_DSP_ShowConfigDialog, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_DSP_ShowConfigDialog
#endif
FMOD_DSP_ShowConfigDialog:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2300+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $575, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_DSP_ShowConfigDialog
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Debug_Initialize
  .p2align 4
  .type FMOD_Debug_Initialize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Debug_Initialize
#endif
FMOD_Debug_Initialize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2304+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $576, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Debug_Initialize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_File_GetDiskBusy
  .p2align 4
  .type FMOD_File_GetDiskBusy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_File_GetDiskBusy
#endif
FMOD_File_GetDiskBusy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2308+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $577, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_File_GetDiskBusy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_File_SetDiskBusy
  .p2align 4
  .type FMOD_File_SetDiskBusy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_File_SetDiskBusy
#endif
FMOD_File_SetDiskBusy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2312+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $578, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_File_SetDiskBusy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_AddPolygon
  .p2align 4
  .type FMOD_Geometry_AddPolygon, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_AddPolygon
#endif
FMOD_Geometry_AddPolygon:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2316+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $579, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_AddPolygon
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetActive
  .p2align 4
  .type FMOD_Geometry_GetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetActive
#endif
FMOD_Geometry_GetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2320+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $580, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetMaxPolygons
  .p2align 4
  .type FMOD_Geometry_GetMaxPolygons, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetMaxPolygons
#endif
FMOD_Geometry_GetMaxPolygons:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2324+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $581, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetMaxPolygons
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetNumPolygons
  .p2align 4
  .type FMOD_Geometry_GetNumPolygons, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetNumPolygons
#endif
FMOD_Geometry_GetNumPolygons:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2328+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $582, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetNumPolygons
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetPolygonAttributes
  .p2align 4
  .type FMOD_Geometry_GetPolygonAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetPolygonAttributes
#endif
FMOD_Geometry_GetPolygonAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2332+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $583, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetPolygonAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetPolygonNumVertices
  .p2align 4
  .type FMOD_Geometry_GetPolygonNumVertices, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetPolygonNumVertices
#endif
FMOD_Geometry_GetPolygonNumVertices:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2336+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $584, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetPolygonNumVertices
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetPolygonVertex
  .p2align 4
  .type FMOD_Geometry_GetPolygonVertex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetPolygonVertex
#endif
FMOD_Geometry_GetPolygonVertex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2340+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $585, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetPolygonVertex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetPosition
  .p2align 4
  .type FMOD_Geometry_GetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetPosition
#endif
FMOD_Geometry_GetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2344+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $586, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetRotation
  .p2align 4
  .type FMOD_Geometry_GetRotation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetRotation
#endif
FMOD_Geometry_GetRotation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2348+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $587, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetRotation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetScale
  .p2align 4
  .type FMOD_Geometry_GetScale, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetScale
#endif
FMOD_Geometry_GetScale:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2352+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $588, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetScale
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_GetUserData
  .p2align 4
  .type FMOD_Geometry_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_GetUserData
#endif
FMOD_Geometry_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2356+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $589, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_Release
  .p2align 4
  .type FMOD_Geometry_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_Release
#endif
FMOD_Geometry_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2360+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $590, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_Save
  .p2align 4
  .type FMOD_Geometry_Save, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_Save
#endif
FMOD_Geometry_Save:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2364+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $591, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_Save
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetActive
  .p2align 4
  .type FMOD_Geometry_SetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetActive
#endif
FMOD_Geometry_SetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2368+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $592, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetPolygonAttributes
  .p2align 4
  .type FMOD_Geometry_SetPolygonAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetPolygonAttributes
#endif
FMOD_Geometry_SetPolygonAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2372+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $593, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetPolygonAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetPolygonVertex
  .p2align 4
  .type FMOD_Geometry_SetPolygonVertex, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetPolygonVertex
#endif
FMOD_Geometry_SetPolygonVertex:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2376+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $594, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetPolygonVertex
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetPosition
  .p2align 4
  .type FMOD_Geometry_SetPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetPosition
#endif
FMOD_Geometry_SetPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2380+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $595, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetRotation
  .p2align 4
  .type FMOD_Geometry_SetRotation, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetRotation
#endif
FMOD_Geometry_SetRotation:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2384+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $596, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetRotation
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetScale
  .p2align 4
  .type FMOD_Geometry_SetScale, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetScale
#endif
FMOD_Geometry_SetScale:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2388+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $597, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetScale
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Geometry_SetUserData
  .p2align 4
  .type FMOD_Geometry_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Geometry_SetUserData
#endif
FMOD_Geometry_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2392+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $598, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Geometry_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Memory_GetStats
  .p2align 4
  .type FMOD_Memory_GetStats, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Memory_GetStats
#endif
FMOD_Memory_GetStats:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2396+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $599, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Memory_GetStats
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Memory_Initialize
  .p2align 4
  .type FMOD_Memory_Initialize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Memory_Initialize
#endif
FMOD_Memory_Initialize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2400+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $600, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Memory_Initialize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_Get3DAttributes
  .p2align 4
  .type FMOD_Reverb3D_Get3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_Get3DAttributes
#endif
FMOD_Reverb3D_Get3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2404+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $601, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_Get3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_GetActive
  .p2align 4
  .type FMOD_Reverb3D_GetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_GetActive
#endif
FMOD_Reverb3D_GetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2408+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $602, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_GetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_GetProperties
  .p2align 4
  .type FMOD_Reverb3D_GetProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_GetProperties
#endif
FMOD_Reverb3D_GetProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2412+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $603, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_GetProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_GetUserData
  .p2align 4
  .type FMOD_Reverb3D_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_GetUserData
#endif
FMOD_Reverb3D_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2416+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $604, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_Release
  .p2align 4
  .type FMOD_Reverb3D_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_Release
#endif
FMOD_Reverb3D_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2420+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $605, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_Set3DAttributes
  .p2align 4
  .type FMOD_Reverb3D_Set3DAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_Set3DAttributes
#endif
FMOD_Reverb3D_Set3DAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2424+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $606, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_Set3DAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_SetActive
  .p2align 4
  .type FMOD_Reverb3D_SetActive, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_SetActive
#endif
FMOD_Reverb3D_SetActive:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2428+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $607, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_SetActive
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_SetProperties
  .p2align 4
  .type FMOD_Reverb3D_SetProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_SetProperties
#endif
FMOD_Reverb3D_SetProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2432+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $608, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_SetProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Reverb3D_SetUserData
  .p2align 4
  .type FMOD_Reverb3D_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Reverb3D_SetUserData
#endif
FMOD_Reverb3D_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2436+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $609, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Reverb3D_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetMaxAudible
  .p2align 4
  .type FMOD_SoundGroup_GetMaxAudible, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetMaxAudible
#endif
FMOD_SoundGroup_GetMaxAudible:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2440+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $610, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetMaxAudible
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetMaxAudibleBehavior
  .p2align 4
  .type FMOD_SoundGroup_GetMaxAudibleBehavior, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetMaxAudibleBehavior
#endif
FMOD_SoundGroup_GetMaxAudibleBehavior:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2444+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $611, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetMaxAudibleBehavior
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetMuteFadeSpeed
  .p2align 4
  .type FMOD_SoundGroup_GetMuteFadeSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetMuteFadeSpeed
#endif
FMOD_SoundGroup_GetMuteFadeSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2448+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $612, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetMuteFadeSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetName
  .p2align 4
  .type FMOD_SoundGroup_GetName, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetName
#endif
FMOD_SoundGroup_GetName:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2452+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $613, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetName
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetNumPlaying
  .p2align 4
  .type FMOD_SoundGroup_GetNumPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetNumPlaying
#endif
FMOD_SoundGroup_GetNumPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2456+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $614, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetNumPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetNumSounds
  .p2align 4
  .type FMOD_SoundGroup_GetNumSounds, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetNumSounds
#endif
FMOD_SoundGroup_GetNumSounds:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2460+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $615, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetNumSounds
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetSound
  .p2align 4
  .type FMOD_SoundGroup_GetSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetSound
#endif
FMOD_SoundGroup_GetSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2464+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $616, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetSystemObject
  .p2align 4
  .type FMOD_SoundGroup_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetSystemObject
#endif
FMOD_SoundGroup_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2468+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $617, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetUserData
  .p2align 4
  .type FMOD_SoundGroup_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetUserData
#endif
FMOD_SoundGroup_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2472+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $618, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_GetVolume
  .p2align 4
  .type FMOD_SoundGroup_GetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_GetVolume
#endif
FMOD_SoundGroup_GetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2476+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $619, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_GetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_Release
  .p2align 4
  .type FMOD_SoundGroup_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_Release
#endif
FMOD_SoundGroup_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2480+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $620, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_SetMaxAudible
  .p2align 4
  .type FMOD_SoundGroup_SetMaxAudible, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_SetMaxAudible
#endif
FMOD_SoundGroup_SetMaxAudible:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2484+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $621, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_SetMaxAudible
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_SetMaxAudibleBehavior
  .p2align 4
  .type FMOD_SoundGroup_SetMaxAudibleBehavior, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_SetMaxAudibleBehavior
#endif
FMOD_SoundGroup_SetMaxAudibleBehavior:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2488+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $622, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_SetMaxAudibleBehavior
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_SetMuteFadeSpeed
  .p2align 4
  .type FMOD_SoundGroup_SetMuteFadeSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_SetMuteFadeSpeed
#endif
FMOD_SoundGroup_SetMuteFadeSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2492+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $623, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_SetMuteFadeSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_SetUserData
  .p2align 4
  .type FMOD_SoundGroup_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_SetUserData
#endif
FMOD_SoundGroup_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2496+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $624, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_SetVolume
  .p2align 4
  .type FMOD_SoundGroup_SetVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_SetVolume
#endif
FMOD_SoundGroup_SetVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2500+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $625, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_SetVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_SoundGroup_Stop
  .p2align 4
  .type FMOD_SoundGroup_Stop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_SoundGroup_Stop
#endif
FMOD_SoundGroup_Stop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2504+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $626, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_SoundGroup_Stop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_AddSyncPoint
  .p2align 4
  .type FMOD_Sound_AddSyncPoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_AddSyncPoint
#endif
FMOD_Sound_AddSyncPoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2508+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $627, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_AddSyncPoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_DeleteSyncPoint
  .p2align 4
  .type FMOD_Sound_DeleteSyncPoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_DeleteSyncPoint
#endif
FMOD_Sound_DeleteSyncPoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2512+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $628, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_DeleteSyncPoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Get3DConeSettings
  .p2align 4
  .type FMOD_Sound_Get3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Get3DConeSettings
#endif
FMOD_Sound_Get3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2516+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $629, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Get3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Get3DCustomRolloff
  .p2align 4
  .type FMOD_Sound_Get3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Get3DCustomRolloff
#endif
FMOD_Sound_Get3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2520+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $630, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Get3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Get3DMinMaxDistance
  .p2align 4
  .type FMOD_Sound_Get3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Get3DMinMaxDistance
#endif
FMOD_Sound_Get3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2524+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $631, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Get3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetDefaults
  .p2align 4
  .type FMOD_Sound_GetDefaults, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetDefaults
#endif
FMOD_Sound_GetDefaults:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2528+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $632, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetDefaults
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetFormat
  .p2align 4
  .type FMOD_Sound_GetFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetFormat
#endif
FMOD_Sound_GetFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2532+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $633, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetLength
  .p2align 4
  .type FMOD_Sound_GetLength, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetLength
#endif
FMOD_Sound_GetLength:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2536+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $634, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetLength
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetLoopCount
  .p2align 4
  .type FMOD_Sound_GetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetLoopCount
#endif
FMOD_Sound_GetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2540+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $635, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetLoopPoints
  .p2align 4
  .type FMOD_Sound_GetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetLoopPoints
#endif
FMOD_Sound_GetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2544+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $636, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetMode
  .p2align 4
  .type FMOD_Sound_GetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetMode
#endif
FMOD_Sound_GetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2548+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $637, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetMusicChannelVolume
  .p2align 4
  .type FMOD_Sound_GetMusicChannelVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetMusicChannelVolume
#endif
FMOD_Sound_GetMusicChannelVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2552+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $638, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetMusicChannelVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetMusicNumChannels
  .p2align 4
  .type FMOD_Sound_GetMusicNumChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetMusicNumChannels
#endif
FMOD_Sound_GetMusicNumChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2556+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $639, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetMusicNumChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetMusicSpeed
  .p2align 4
  .type FMOD_Sound_GetMusicSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetMusicSpeed
#endif
FMOD_Sound_GetMusicSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2560+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $640, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetMusicSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetName
  .p2align 4
  .type FMOD_Sound_GetName, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetName
#endif
FMOD_Sound_GetName:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2564+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $641, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetName
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetNumSubSounds
  .p2align 4
  .type FMOD_Sound_GetNumSubSounds, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetNumSubSounds
#endif
FMOD_Sound_GetNumSubSounds:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2568+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $642, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetNumSubSounds
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetNumSyncPoints
  .p2align 4
  .type FMOD_Sound_GetNumSyncPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetNumSyncPoints
#endif
FMOD_Sound_GetNumSyncPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2572+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $643, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetNumSyncPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetNumTags
  .p2align 4
  .type FMOD_Sound_GetNumTags, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetNumTags
#endif
FMOD_Sound_GetNumTags:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2576+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $644, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetNumTags
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetOpenState
  .p2align 4
  .type FMOD_Sound_GetOpenState, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetOpenState
#endif
FMOD_Sound_GetOpenState:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2580+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $645, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetOpenState
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetSoundGroup
  .p2align 4
  .type FMOD_Sound_GetSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetSoundGroup
#endif
FMOD_Sound_GetSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2584+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $646, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetSubSound
  .p2align 4
  .type FMOD_Sound_GetSubSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetSubSound
#endif
FMOD_Sound_GetSubSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2588+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $647, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetSubSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetSubSoundParent
  .p2align 4
  .type FMOD_Sound_GetSubSoundParent, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetSubSoundParent
#endif
FMOD_Sound_GetSubSoundParent:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2592+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $648, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetSubSoundParent
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetSyncPoint
  .p2align 4
  .type FMOD_Sound_GetSyncPoint, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetSyncPoint
#endif
FMOD_Sound_GetSyncPoint:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2596+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $649, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetSyncPoint
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetSyncPointInfo
  .p2align 4
  .type FMOD_Sound_GetSyncPointInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetSyncPointInfo
#endif
FMOD_Sound_GetSyncPointInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2600+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $650, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetSyncPointInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetSystemObject
  .p2align 4
  .type FMOD_Sound_GetSystemObject, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetSystemObject
#endif
FMOD_Sound_GetSystemObject:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2604+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $651, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetSystemObject
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetTag
  .p2align 4
  .type FMOD_Sound_GetTag, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetTag
#endif
FMOD_Sound_GetTag:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2608+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $652, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetTag
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_GetUserData
  .p2align 4
  .type FMOD_Sound_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_GetUserData
#endif
FMOD_Sound_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2612+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $653, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Lock
  .p2align 4
  .type FMOD_Sound_Lock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Lock
#endif
FMOD_Sound_Lock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2616+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $654, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Lock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_ReadData
  .p2align 4
  .type FMOD_Sound_ReadData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_ReadData
#endif
FMOD_Sound_ReadData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2620+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $655, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_ReadData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Release
  .p2align 4
  .type FMOD_Sound_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Release
#endif
FMOD_Sound_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2624+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $656, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SeekData
  .p2align 4
  .type FMOD_Sound_SeekData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SeekData
#endif
FMOD_Sound_SeekData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2628+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $657, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SeekData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Set3DConeSettings
  .p2align 4
  .type FMOD_Sound_Set3DConeSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Set3DConeSettings
#endif
FMOD_Sound_Set3DConeSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2632+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $658, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Set3DConeSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Set3DCustomRolloff
  .p2align 4
  .type FMOD_Sound_Set3DCustomRolloff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Set3DCustomRolloff
#endif
FMOD_Sound_Set3DCustomRolloff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2636+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $659, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Set3DCustomRolloff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Set3DMinMaxDistance
  .p2align 4
  .type FMOD_Sound_Set3DMinMaxDistance, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Set3DMinMaxDistance
#endif
FMOD_Sound_Set3DMinMaxDistance:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2640+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $660, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Set3DMinMaxDistance
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetDefaults
  .p2align 4
  .type FMOD_Sound_SetDefaults, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetDefaults
#endif
FMOD_Sound_SetDefaults:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2644+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $661, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetDefaults
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetLoopCount
  .p2align 4
  .type FMOD_Sound_SetLoopCount, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetLoopCount
#endif
FMOD_Sound_SetLoopCount:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2648+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $662, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetLoopCount
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetLoopPoints
  .p2align 4
  .type FMOD_Sound_SetLoopPoints, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetLoopPoints
#endif
FMOD_Sound_SetLoopPoints:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2652+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $663, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetLoopPoints
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetMode
  .p2align 4
  .type FMOD_Sound_SetMode, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetMode
#endif
FMOD_Sound_SetMode:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2656+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $664, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetMode
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetMusicChannelVolume
  .p2align 4
  .type FMOD_Sound_SetMusicChannelVolume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetMusicChannelVolume
#endif
FMOD_Sound_SetMusicChannelVolume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2660+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $665, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetMusicChannelVolume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetMusicSpeed
  .p2align 4
  .type FMOD_Sound_SetMusicSpeed, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetMusicSpeed
#endif
FMOD_Sound_SetMusicSpeed:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2664+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $666, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetMusicSpeed
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetSoundGroup
  .p2align 4
  .type FMOD_Sound_SetSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetSoundGroup
#endif
FMOD_Sound_SetSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2668+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $667, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_SetUserData
  .p2align 4
  .type FMOD_Sound_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_SetUserData
#endif
FMOD_Sound_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2672+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $668, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Sound_Unlock
  .p2align 4
  .type FMOD_Sound_Unlock, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Sound_Unlock
#endif
FMOD_Sound_Unlock:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2676+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $669, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Sound_Unlock
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_AttachChannelGroupToPort
  .p2align 4
  .type FMOD_System_AttachChannelGroupToPort, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_AttachChannelGroupToPort
#endif
FMOD_System_AttachChannelGroupToPort:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2680+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $670, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_AttachChannelGroupToPort
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_AttachFileSystem
  .p2align 4
  .type FMOD_System_AttachFileSystem, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_AttachFileSystem
#endif
FMOD_System_AttachFileSystem:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2684+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $671, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_AttachFileSystem
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Close
  .p2align 4
  .type FMOD_System_Close, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Close
#endif
FMOD_System_Close:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2688+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $672, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Close
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Create
  .p2align 4
  .type FMOD_System_Create, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Create
#endif
FMOD_System_Create:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2692+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $673, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Create
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateChannelGroup
  .p2align 4
  .type FMOD_System_CreateChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateChannelGroup
#endif
FMOD_System_CreateChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2696+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $674, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateDSP
  .p2align 4
  .type FMOD_System_CreateDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateDSP
#endif
FMOD_System_CreateDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2700+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $675, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateDSPByPlugin
  .p2align 4
  .type FMOD_System_CreateDSPByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateDSPByPlugin
#endif
FMOD_System_CreateDSPByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2704+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $676, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateDSPByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateDSPByType
  .p2align 4
  .type FMOD_System_CreateDSPByType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateDSPByType
#endif
FMOD_System_CreateDSPByType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2708+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $677, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateDSPByType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateGeometry
  .p2align 4
  .type FMOD_System_CreateGeometry, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateGeometry
#endif
FMOD_System_CreateGeometry:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2712+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $678, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateGeometry
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateReverb3D
  .p2align 4
  .type FMOD_System_CreateReverb3D, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateReverb3D
#endif
FMOD_System_CreateReverb3D:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2716+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $679, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateReverb3D
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateSound
  .p2align 4
  .type FMOD_System_CreateSound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateSound
#endif
FMOD_System_CreateSound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2720+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $680, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateSound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateSoundGroup
  .p2align 4
  .type FMOD_System_CreateSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateSoundGroup
#endif
FMOD_System_CreateSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2724+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $681, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_CreateStream
  .p2align 4
  .type FMOD_System_CreateStream, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_CreateStream
#endif
FMOD_System_CreateStream:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2728+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $682, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_CreateStream
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_DetachChannelGroupFromPort
  .p2align 4
  .type FMOD_System_DetachChannelGroupFromPort, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_DetachChannelGroupFromPort
#endif
FMOD_System_DetachChannelGroupFromPort:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2732+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $683, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_DetachChannelGroupFromPort
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Get3DListenerAttributes
  .p2align 4
  .type FMOD_System_Get3DListenerAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Get3DListenerAttributes
#endif
FMOD_System_Get3DListenerAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2736+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $684, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Get3DListenerAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Get3DNumListeners
  .p2align 4
  .type FMOD_System_Get3DNumListeners, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Get3DNumListeners
#endif
FMOD_System_Get3DNumListeners:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2740+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $685, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Get3DNumListeners
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Get3DSettings
  .p2align 4
  .type FMOD_System_Get3DSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Get3DSettings
#endif
FMOD_System_Get3DSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2744+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $686, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Get3DSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetAdvancedSettings
  .p2align 4
  .type FMOD_System_GetAdvancedSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetAdvancedSettings
#endif
FMOD_System_GetAdvancedSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2748+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $687, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetAdvancedSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetCPUUsage
  .p2align 4
  .type FMOD_System_GetCPUUsage, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetCPUUsage
#endif
FMOD_System_GetCPUUsage:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2752+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $688, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetCPUUsage
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetChannel
  .p2align 4
  .type FMOD_System_GetChannel, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetChannel
#endif
FMOD_System_GetChannel:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2756+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $689, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetChannel
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetChannelsPlaying
  .p2align 4
  .type FMOD_System_GetChannelsPlaying, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetChannelsPlaying
#endif
FMOD_System_GetChannelsPlaying:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2760+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $690, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetChannelsPlaying
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetDSPBufferSize
  .p2align 4
  .type FMOD_System_GetDSPBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetDSPBufferSize
#endif
FMOD_System_GetDSPBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2764+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $691, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetDSPBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetDSPInfoByPlugin
  .p2align 4
  .type FMOD_System_GetDSPInfoByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetDSPInfoByPlugin
#endif
FMOD_System_GetDSPInfoByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2768+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $692, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetDSPInfoByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetDSPInfoByType
  .p2align 4
  .type FMOD_System_GetDSPInfoByType, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetDSPInfoByType
#endif
FMOD_System_GetDSPInfoByType:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2772+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $693, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetDSPInfoByType
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetDefaultMixMatrix
  .p2align 4
  .type FMOD_System_GetDefaultMixMatrix, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetDefaultMixMatrix
#endif
FMOD_System_GetDefaultMixMatrix:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2776+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $694, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetDefaultMixMatrix
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetDriver
  .p2align 4
  .type FMOD_System_GetDriver, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetDriver
#endif
FMOD_System_GetDriver:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2780+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $695, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetDriver
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetDriverInfo
  .p2align 4
  .type FMOD_System_GetDriverInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetDriverInfo
#endif
FMOD_System_GetDriverInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2784+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $696, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetDriverInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetFileUsage
  .p2align 4
  .type FMOD_System_GetFileUsage, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetFileUsage
#endif
FMOD_System_GetFileUsage:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2788+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $697, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetFileUsage
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetGeometryOcclusion
  .p2align 4
  .type FMOD_System_GetGeometryOcclusion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetGeometryOcclusion
#endif
FMOD_System_GetGeometryOcclusion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2792+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $698, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetGeometryOcclusion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetGeometrySettings
  .p2align 4
  .type FMOD_System_GetGeometrySettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetGeometrySettings
#endif
FMOD_System_GetGeometrySettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2796+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $699, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetGeometrySettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetMasterChannelGroup
  .p2align 4
  .type FMOD_System_GetMasterChannelGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetMasterChannelGroup
#endif
FMOD_System_GetMasterChannelGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2800+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $700, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetMasterChannelGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetMasterSoundGroup
  .p2align 4
  .type FMOD_System_GetMasterSoundGroup, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetMasterSoundGroup
#endif
FMOD_System_GetMasterSoundGroup:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2804+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $701, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetMasterSoundGroup
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetNestedPlugin
  .p2align 4
  .type FMOD_System_GetNestedPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetNestedPlugin
#endif
FMOD_System_GetNestedPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2808+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $702, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetNestedPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetNetworkProxy
  .p2align 4
  .type FMOD_System_GetNetworkProxy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetNetworkProxy
#endif
FMOD_System_GetNetworkProxy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2812+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $703, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetNetworkProxy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetNetworkTimeout
  .p2align 4
  .type FMOD_System_GetNetworkTimeout, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetNetworkTimeout
#endif
FMOD_System_GetNetworkTimeout:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2816+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $704, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetNetworkTimeout
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetNumDrivers
  .p2align 4
  .type FMOD_System_GetNumDrivers, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetNumDrivers
#endif
FMOD_System_GetNumDrivers:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2820+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $705, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetNumDrivers
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetNumNestedPlugins
  .p2align 4
  .type FMOD_System_GetNumNestedPlugins, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetNumNestedPlugins
#endif
FMOD_System_GetNumNestedPlugins:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2824+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $706, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetNumNestedPlugins
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetNumPlugins
  .p2align 4
  .type FMOD_System_GetNumPlugins, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetNumPlugins
#endif
FMOD_System_GetNumPlugins:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2828+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $707, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetNumPlugins
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetOutput
  .p2align 4
  .type FMOD_System_GetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetOutput
#endif
FMOD_System_GetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2832+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $708, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetOutputByPlugin
  .p2align 4
  .type FMOD_System_GetOutputByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetOutputByPlugin
#endif
FMOD_System_GetOutputByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2836+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $709, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetOutputByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetOutputHandle
  .p2align 4
  .type FMOD_System_GetOutputHandle, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetOutputHandle
#endif
FMOD_System_GetOutputHandle:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2840+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $710, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetOutputHandle
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetPluginHandle
  .p2align 4
  .type FMOD_System_GetPluginHandle, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetPluginHandle
#endif
FMOD_System_GetPluginHandle:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2844+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $711, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetPluginHandle
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetPluginInfo
  .p2align 4
  .type FMOD_System_GetPluginInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetPluginInfo
#endif
FMOD_System_GetPluginInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2848+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $712, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetPluginInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetRecordDriverInfo
  .p2align 4
  .type FMOD_System_GetRecordDriverInfo, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetRecordDriverInfo
#endif
FMOD_System_GetRecordDriverInfo:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2852+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $713, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetRecordDriverInfo
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetRecordNumDrivers
  .p2align 4
  .type FMOD_System_GetRecordNumDrivers, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetRecordNumDrivers
#endif
FMOD_System_GetRecordNumDrivers:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2856+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $714, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetRecordNumDrivers
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetRecordPosition
  .p2align 4
  .type FMOD_System_GetRecordPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetRecordPosition
#endif
FMOD_System_GetRecordPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2860+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $715, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetRecordPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetReverbProperties
  .p2align 4
  .type FMOD_System_GetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetReverbProperties
#endif
FMOD_System_GetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2864+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $716, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetSoftwareChannels
  .p2align 4
  .type FMOD_System_GetSoftwareChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetSoftwareChannels
#endif
FMOD_System_GetSoftwareChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2868+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $717, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetSoftwareChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetSoftwareFormat
  .p2align 4
  .type FMOD_System_GetSoftwareFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetSoftwareFormat
#endif
FMOD_System_GetSoftwareFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2872+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $718, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetSoftwareFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetSpeakerModeChannels
  .p2align 4
  .type FMOD_System_GetSpeakerModeChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetSpeakerModeChannels
#endif
FMOD_System_GetSpeakerModeChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2876+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $719, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetSpeakerModeChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetSpeakerPosition
  .p2align 4
  .type FMOD_System_GetSpeakerPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetSpeakerPosition
#endif
FMOD_System_GetSpeakerPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2880+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $720, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetSpeakerPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetStreamBufferSize
  .p2align 4
  .type FMOD_System_GetStreamBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetStreamBufferSize
#endif
FMOD_System_GetStreamBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2884+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $721, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetStreamBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetUserData
  .p2align 4
  .type FMOD_System_GetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetUserData
#endif
FMOD_System_GetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2888+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $722, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_GetVersion
  .p2align 4
  .type FMOD_System_GetVersion, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_GetVersion
#endif
FMOD_System_GetVersion:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2892+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $723, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_GetVersion
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Init
  .p2align 4
  .type FMOD_System_Init, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Init
#endif
FMOD_System_Init:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2896+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $724, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Init
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_IsRecording
  .p2align 4
  .type FMOD_System_IsRecording, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_IsRecording
#endif
FMOD_System_IsRecording:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2900+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $725, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_IsRecording
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_LoadGeometry
  .p2align 4
  .type FMOD_System_LoadGeometry, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_LoadGeometry
#endif
FMOD_System_LoadGeometry:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2904+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $726, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_LoadGeometry
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_LoadPlugin
  .p2align 4
  .type FMOD_System_LoadPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_LoadPlugin
#endif
FMOD_System_LoadPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2908+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $727, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_LoadPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_LockDSP
  .p2align 4
  .type FMOD_System_LockDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_LockDSP
#endif
FMOD_System_LockDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2912+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $728, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_LockDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_MixerResume
  .p2align 4
  .type FMOD_System_MixerResume, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_MixerResume
#endif
FMOD_System_MixerResume:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2916+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $729, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_MixerResume
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_MixerSuspend
  .p2align 4
  .type FMOD_System_MixerSuspend, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_MixerSuspend
#endif
FMOD_System_MixerSuspend:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2920+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $730, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_MixerSuspend
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_PlayDSP
  .p2align 4
  .type FMOD_System_PlayDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_PlayDSP
#endif
FMOD_System_PlayDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2924+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $731, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_PlayDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_PlaySound
  .p2align 4
  .type FMOD_System_PlaySound, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_PlaySound
#endif
FMOD_System_PlaySound:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2928+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $732, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_PlaySound
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_RecordStart
  .p2align 4
  .type FMOD_System_RecordStart, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_RecordStart
#endif
FMOD_System_RecordStart:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2932+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $733, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_RecordStart
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_RecordStop
  .p2align 4
  .type FMOD_System_RecordStop, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_RecordStop
#endif
FMOD_System_RecordStop:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2936+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $734, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_RecordStop
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_RegisterCodec
  .p2align 4
  .type FMOD_System_RegisterCodec, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_RegisterCodec
#endif
FMOD_System_RegisterCodec:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2940+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $735, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_RegisterCodec
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_RegisterDSP
  .p2align 4
  .type FMOD_System_RegisterDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_RegisterDSP
#endif
FMOD_System_RegisterDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2944+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $736, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_RegisterDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_RegisterOutput
  .p2align 4
  .type FMOD_System_RegisterOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_RegisterOutput
#endif
FMOD_System_RegisterOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2948+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $737, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_RegisterOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Release
  .p2align 4
  .type FMOD_System_Release, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Release
#endif
FMOD_System_Release:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2952+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $738, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Release
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Set3DListenerAttributes
  .p2align 4
  .type FMOD_System_Set3DListenerAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Set3DListenerAttributes
#endif
FMOD_System_Set3DListenerAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2956+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $739, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Set3DListenerAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Set3DNumListeners
  .p2align 4
  .type FMOD_System_Set3DNumListeners, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Set3DNumListeners
#endif
FMOD_System_Set3DNumListeners:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2960+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $740, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Set3DNumListeners
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Set3DRolloffCallback
  .p2align 4
  .type FMOD_System_Set3DRolloffCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Set3DRolloffCallback
#endif
FMOD_System_Set3DRolloffCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2964+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $741, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Set3DRolloffCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Set3DSettings
  .p2align 4
  .type FMOD_System_Set3DSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Set3DSettings
#endif
FMOD_System_Set3DSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2968+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $742, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Set3DSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetAdvancedSettings
  .p2align 4
  .type FMOD_System_SetAdvancedSettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetAdvancedSettings
#endif
FMOD_System_SetAdvancedSettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2972+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $743, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetAdvancedSettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetCallback
  .p2align 4
  .type FMOD_System_SetCallback, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetCallback
#endif
FMOD_System_SetCallback:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2976+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $744, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetCallback
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetDSPBufferSize
  .p2align 4
  .type FMOD_System_SetDSPBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetDSPBufferSize
#endif
FMOD_System_SetDSPBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2980+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $745, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetDSPBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetDriver
  .p2align 4
  .type FMOD_System_SetDriver, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetDriver
#endif
FMOD_System_SetDriver:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2984+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $746, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetDriver
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetFileSystem
  .p2align 4
  .type FMOD_System_SetFileSystem, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetFileSystem
#endif
FMOD_System_SetFileSystem:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2988+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $747, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetFileSystem
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetGeometrySettings
  .p2align 4
  .type FMOD_System_SetGeometrySettings, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetGeometrySettings
#endif
FMOD_System_SetGeometrySettings:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2992+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $748, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetGeometrySettings
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetNetworkProxy
  .p2align 4
  .type FMOD_System_SetNetworkProxy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetNetworkProxy
#endif
FMOD_System_SetNetworkProxy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 2996+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $749, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetNetworkProxy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetNetworkTimeout
  .p2align 4
  .type FMOD_System_SetNetworkTimeout, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetNetworkTimeout
#endif
FMOD_System_SetNetworkTimeout:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3000+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $750, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetNetworkTimeout
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetOutput
  .p2align 4
  .type FMOD_System_SetOutput, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetOutput
#endif
FMOD_System_SetOutput:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3004+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $751, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetOutput
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetOutputByPlugin
  .p2align 4
  .type FMOD_System_SetOutputByPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetOutputByPlugin
#endif
FMOD_System_SetOutputByPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3008+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $752, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetOutputByPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetPluginPath
  .p2align 4
  .type FMOD_System_SetPluginPath, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetPluginPath
#endif
FMOD_System_SetPluginPath:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3012+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $753, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetPluginPath
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetReverbProperties
  .p2align 4
  .type FMOD_System_SetReverbProperties, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetReverbProperties
#endif
FMOD_System_SetReverbProperties:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3016+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $754, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetReverbProperties
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetSoftwareChannels
  .p2align 4
  .type FMOD_System_SetSoftwareChannels, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetSoftwareChannels
#endif
FMOD_System_SetSoftwareChannels:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3020+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $755, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetSoftwareChannels
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetSoftwareFormat
  .p2align 4
  .type FMOD_System_SetSoftwareFormat, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetSoftwareFormat
#endif
FMOD_System_SetSoftwareFormat:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3024+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $756, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetSoftwareFormat
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetSpeakerPosition
  .p2align 4
  .type FMOD_System_SetSpeakerPosition, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetSpeakerPosition
#endif
FMOD_System_SetSpeakerPosition:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3028+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $757, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetSpeakerPosition
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetStreamBufferSize
  .p2align 4
  .type FMOD_System_SetStreamBufferSize, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetStreamBufferSize
#endif
FMOD_System_SetStreamBufferSize:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3032+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $758, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetStreamBufferSize
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_SetUserData
  .p2align 4
  .type FMOD_System_SetUserData, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_SetUserData
#endif
FMOD_System_SetUserData:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3036+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $759, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_SetUserData
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_UnloadPlugin
  .p2align 4
  .type FMOD_System_UnloadPlugin, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_UnloadPlugin
#endif
FMOD_System_UnloadPlugin:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3040+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $760, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_UnloadPlugin
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_UnlockDSP
  .p2align 4
  .type FMOD_System_UnlockDSP, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_UnlockDSP
#endif
FMOD_System_UnlockDSP:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3044+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $761, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_UnlockDSP
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_System_Update
  .p2align 4
  .type FMOD_System_Update, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_System_Update
#endif
FMOD_System_Update:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3048+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $762, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_System_Update
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl FMOD_Thread_SetAttributes
  .p2align 4
  .type FMOD_Thread_SetAttributes, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden FMOD_Thread_SetAttributes
#endif
FMOD_Thread_SetAttributes:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3052+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $763, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp FMOD_Thread_SetAttributes
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD10SoundGroup11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup11getUserDataEPPv
#endif
_ZN4FMOD10SoundGroup11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3056+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $764, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD10SoundGroup11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup11setUserDataEPv
#endif
_ZN4FMOD10SoundGroup11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3060+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $765, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup12getNumSoundsEPi
  .p2align 4
  .type _ZN4FMOD10SoundGroup12getNumSoundsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup12getNumSoundsEPi
#endif
_ZN4FMOD10SoundGroup12getNumSoundsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3064+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $766, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup12getNumSoundsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup13getMaxAudibleEPi
  .p2align 4
  .type _ZN4FMOD10SoundGroup13getMaxAudibleEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup13getMaxAudibleEPi
#endif
_ZN4FMOD10SoundGroup13getMaxAudibleEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3068+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $767, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup13getMaxAudibleEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup13getNumPlayingEPi
  .p2align 4
  .type _ZN4FMOD10SoundGroup13getNumPlayingEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup13getNumPlayingEPi
#endif
_ZN4FMOD10SoundGroup13getNumPlayingEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3072+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $768, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup13getNumPlayingEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup13setMaxAudibleEi
  .p2align 4
  .type _ZN4FMOD10SoundGroup13setMaxAudibleEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup13setMaxAudibleEi
#endif
_ZN4FMOD10SoundGroup13setMaxAudibleEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3076+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $769, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup13setMaxAudibleEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup15getSystemObjectEPPNS_6SystemE
  .p2align 4
  .type _ZN4FMOD10SoundGroup15getSystemObjectEPPNS_6SystemE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup15getSystemObjectEPPNS_6SystemE
#endif
_ZN4FMOD10SoundGroup15getSystemObjectEPPNS_6SystemE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3080+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $770, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup15getSystemObjectEPPNS_6SystemE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup16getMuteFadeSpeedEPf
  .p2align 4
  .type _ZN4FMOD10SoundGroup16getMuteFadeSpeedEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup16getMuteFadeSpeedEPf
#endif
_ZN4FMOD10SoundGroup16getMuteFadeSpeedEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3084+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $771, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup16getMuteFadeSpeedEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup16setMuteFadeSpeedEf
  .p2align 4
  .type _ZN4FMOD10SoundGroup16setMuteFadeSpeedEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup16setMuteFadeSpeedEf
#endif
_ZN4FMOD10SoundGroup16setMuteFadeSpeedEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3088+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $772, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup16setMuteFadeSpeedEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup21getMaxAudibleBehaviorEP24FMOD_SOUNDGROUP_BEHAVIOR
  .p2align 4
  .type _ZN4FMOD10SoundGroup21getMaxAudibleBehaviorEP24FMOD_SOUNDGROUP_BEHAVIOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup21getMaxAudibleBehaviorEP24FMOD_SOUNDGROUP_BEHAVIOR
#endif
_ZN4FMOD10SoundGroup21getMaxAudibleBehaviorEP24FMOD_SOUNDGROUP_BEHAVIOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3092+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $773, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup21getMaxAudibleBehaviorEP24FMOD_SOUNDGROUP_BEHAVIOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup21setMaxAudibleBehaviorE24FMOD_SOUNDGROUP_BEHAVIOR
  .p2align 4
  .type _ZN4FMOD10SoundGroup21setMaxAudibleBehaviorE24FMOD_SOUNDGROUP_BEHAVIOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup21setMaxAudibleBehaviorE24FMOD_SOUNDGROUP_BEHAVIOR
#endif
_ZN4FMOD10SoundGroup21setMaxAudibleBehaviorE24FMOD_SOUNDGROUP_BEHAVIOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3096+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $774, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup21setMaxAudibleBehaviorE24FMOD_SOUNDGROUP_BEHAVIOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup4stopEv
  .p2align 4
  .type _ZN4FMOD10SoundGroup4stopEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup4stopEv
#endif
_ZN4FMOD10SoundGroup4stopEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3100+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $775, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup4stopEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup7getNameEPci
  .p2align 4
  .type _ZN4FMOD10SoundGroup7getNameEPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup7getNameEPci
#endif
_ZN4FMOD10SoundGroup7getNameEPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3104+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $776, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup7getNameEPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup7releaseEv
  .p2align 4
  .type _ZN4FMOD10SoundGroup7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup7releaseEv
#endif
_ZN4FMOD10SoundGroup7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3108+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $777, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup8getSoundEiPPNS_5SoundE
  .p2align 4
  .type _ZN4FMOD10SoundGroup8getSoundEiPPNS_5SoundE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup8getSoundEiPPNS_5SoundE
#endif
_ZN4FMOD10SoundGroup8getSoundEiPPNS_5SoundE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3112+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $778, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup8getSoundEiPPNS_5SoundE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup9getVolumeEPf
  .p2align 4
  .type _ZN4FMOD10SoundGroup9getVolumeEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup9getVolumeEPf
#endif
_ZN4FMOD10SoundGroup9getVolumeEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3116+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $779, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup9getVolumeEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10SoundGroup9setVolumeEf
  .p2align 4
  .type _ZN4FMOD10SoundGroup9setVolumeEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10SoundGroup9setVolumeEf
#endif
_ZN4FMOD10SoundGroup9setVolumeEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3120+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $780, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10SoundGroup9setVolumeEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD10getGlobalsEPPNS_6GlobalE
  .p2align 4
  .type _ZN4FMOD10getGlobalsEPPNS_6GlobalE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD10getGlobalsEPPNS_6GlobalE
#endif
_ZN4FMOD10getGlobalsEPPNS_6GlobalE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3124+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $781, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD10getGlobalsEPPNS_6GlobalE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup10getChannelEiPPNS_7ChannelE
  .p2align 4
  .type _ZN4FMOD12ChannelGroup10getChannelEiPPNS_7ChannelE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup10getChannelEiPPNS_7ChannelE
#endif
_ZN4FMOD12ChannelGroup10getChannelEiPPNS_7ChannelE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3128+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $782, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup10getChannelEiPPNS_7ChannelE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup12getNumGroupsEPi
  .p2align 4
  .type _ZN4FMOD12ChannelGroup12getNumGroupsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup12getNumGroupsEPi
#endif
_ZN4FMOD12ChannelGroup12getNumGroupsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3132+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $783, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup12getNumGroupsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup14getNumChannelsEPi
  .p2align 4
  .type _ZN4FMOD12ChannelGroup14getNumChannelsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup14getNumChannelsEPi
#endif
_ZN4FMOD12ChannelGroup14getNumChannelsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3136+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $784, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup14getNumChannelsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup14getParentGroupEPPS0_
  .p2align 4
  .type _ZN4FMOD12ChannelGroup14getParentGroupEPPS0_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup14getParentGroupEPPS0_
#endif
_ZN4FMOD12ChannelGroup14getParentGroupEPPS0_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3140+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $785, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup14getParentGroupEPPS0_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup7getNameEPci
  .p2align 4
  .type _ZN4FMOD12ChannelGroup7getNameEPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup7getNameEPci
#endif
_ZN4FMOD12ChannelGroup7getNameEPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3144+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $786, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup7getNameEPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup7releaseEv
  .p2align 4
  .type _ZN4FMOD12ChannelGroup7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup7releaseEv
#endif
_ZN4FMOD12ChannelGroup7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3148+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $787, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup8addGroupEPS0_bPPNS_13DSPConnectionE
  .p2align 4
  .type _ZN4FMOD12ChannelGroup8addGroupEPS0_bPPNS_13DSPConnectionE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup8addGroupEPS0_bPPNS_13DSPConnectionE
#endif
_ZN4FMOD12ChannelGroup8addGroupEPS0_bPPNS_13DSPConnectionE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3152+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $788, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup8addGroupEPS0_bPPNS_13DSPConnectionE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD12ChannelGroup8getGroupEiPPS0_
  .p2align 4
  .type _ZN4FMOD12ChannelGroup8getGroupEiPPS0_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD12ChannelGroup8getGroupEiPPS0_
#endif
_ZN4FMOD12ChannelGroup8getGroupEiPPS0_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3156+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $789, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD12ChannelGroup8getGroupEiPPS0_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD13DSPConnection11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection11getUserDataEPPv
#endif
_ZN4FMOD13DSPConnection11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3160+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $790, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD13DSPConnection11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection11setUserDataEPv
#endif
_ZN4FMOD13DSPConnection11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3164+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $791, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection12getMixMatrixEPfPiS2_i
  .p2align 4
  .type _ZN4FMOD13DSPConnection12getMixMatrixEPfPiS2_i, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection12getMixMatrixEPfPiS2_i
#endif
_ZN4FMOD13DSPConnection12getMixMatrixEPfPiS2_i:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3168+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $792, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection12getMixMatrixEPfPiS2_i
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection12setMixMatrixEPfiii
  .p2align 4
  .type _ZN4FMOD13DSPConnection12setMixMatrixEPfiii, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection12setMixMatrixEPfiii
#endif
_ZN4FMOD13DSPConnection12setMixMatrixEPfiii:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3172+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $793, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection12setMixMatrixEPfiii
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection6getMixEPf
  .p2align 4
  .type _ZN4FMOD13DSPConnection6getMixEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection6getMixEPf
#endif
_ZN4FMOD13DSPConnection6getMixEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3176+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $794, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection6getMixEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection6setMixEf
  .p2align 4
  .type _ZN4FMOD13DSPConnection6setMixEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection6setMixEf
#endif
_ZN4FMOD13DSPConnection6setMixEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3180+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $795, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection6setMixEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection7getTypeEP23FMOD_DSPCONNECTION_TYPE
  .p2align 4
  .type _ZN4FMOD13DSPConnection7getTypeEP23FMOD_DSPCONNECTION_TYPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection7getTypeEP23FMOD_DSPCONNECTION_TYPE
#endif
_ZN4FMOD13DSPConnection7getTypeEP23FMOD_DSPCONNECTION_TYPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3184+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $796, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection7getTypeEP23FMOD_DSPCONNECTION_TYPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection8getInputEPPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD13DSPConnection8getInputEPPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection8getInputEPPNS_3DSPE
#endif
_ZN4FMOD13DSPConnection8getInputEPPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3188+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $797, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection8getInputEPPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD13DSPConnection9getOutputEPPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD13DSPConnection9getOutputEPPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD13DSPConnection9getOutputEPPNS_3DSPE
#endif
_ZN4FMOD13DSPConnection9getOutputEPPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3192+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $798, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD13DSPConnection9getOutputEPPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl10get3DLevelEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl10get3DLevelEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl10get3DLevelEPf
#endif
_ZN4FMOD14ChannelControl10get3DLevelEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3196+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $799, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl10get3DLevelEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl10getNumDSPsEPi
  .p2align 4
  .type _ZN4FMOD14ChannelControl10getNumDSPsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl10getNumDSPsEPi
#endif
_ZN4FMOD14ChannelControl10getNumDSPsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3200+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $800, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl10getNumDSPsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl10set3DLevelEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl10set3DLevelEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl10set3DLevelEf
#endif
_ZN4FMOD14ChannelControl10set3DLevelEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3204+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $801, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl10set3DLevelEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11get3DSpreadEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl11get3DSpreadEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11get3DSpreadEPf
#endif
_ZN4FMOD14ChannelControl11get3DSpreadEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3208+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $802, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11get3DSpreadEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11getDSPClockEPyS1_
  .p2align 4
  .type _ZN4FMOD14ChannelControl11getDSPClockEPyS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11getDSPClockEPyS1_
#endif
_ZN4FMOD14ChannelControl11getDSPClockEPyS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3212+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $803, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11getDSPClockEPyS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11getDSPIndexEPNS_3DSPEPi
  .p2align 4
  .type _ZN4FMOD14ChannelControl11getDSPIndexEPNS_3DSPEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11getDSPIndexEPNS_3DSPEPi
#endif
_ZN4FMOD14ChannelControl11getDSPIndexEPNS_3DSPEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3216+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $804, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11getDSPIndexEPNS_3DSPEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD14ChannelControl11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11getUserDataEPPv
#endif
_ZN4FMOD14ChannelControl11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3220+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $805, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11set3DSpreadEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl11set3DSpreadEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11set3DSpreadEf
#endif
_ZN4FMOD14ChannelControl11set3DSpreadEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3224+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $806, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11set3DSpreadEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11setCallbackEPF11FMOD_RESULTP19FMOD_CHANNELCONTROL24FMOD_CHANNELCONTROL_TYPE33FMOD_CHANNELCONTROL_CALLBACK_TYPEPvS6_E
  .p2align 4
  .type _ZN4FMOD14ChannelControl11setCallbackEPF11FMOD_RESULTP19FMOD_CHANNELCONTROL24FMOD_CHANNELCONTROL_TYPE33FMOD_CHANNELCONTROL_CALLBACK_TYPEPvS6_E, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11setCallbackEPF11FMOD_RESULTP19FMOD_CHANNELCONTROL24FMOD_CHANNELCONTROL_TYPE33FMOD_CHANNELCONTROL_CALLBACK_TYPEPvS6_E
#endif
_ZN4FMOD14ChannelControl11setCallbackEPF11FMOD_RESULTP19FMOD_CHANNELCONTROL24FMOD_CHANNELCONTROL_TYPE33FMOD_CHANNELCONTROL_CALLBACK_TYPEPvS6_E:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3228+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $807, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11setCallbackEPF11FMOD_RESULTP19FMOD_CHANNELCONTROL24FMOD_CHANNELCONTROL_TYPE33FMOD_CHANNELCONTROL_CALLBACK_TYPEPvS6_E
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11setDSPIndexEPNS_3DSPEi
  .p2align 4
  .type _ZN4FMOD14ChannelControl11setDSPIndexEPNS_3DSPEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11setDSPIndexEPNS_3DSPEi
#endif
_ZN4FMOD14ChannelControl11setDSPIndexEPNS_3DSPEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3232+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $808, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11setDSPIndexEPNS_3DSPEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD14ChannelControl11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl11setUserDataEPv
#endif
_ZN4FMOD14ChannelControl11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3236+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $809, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl12addFadePointEyf
  .p2align 4
  .type _ZN4FMOD14ChannelControl12addFadePointEyf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl12addFadePointEyf
#endif
_ZN4FMOD14ChannelControl12addFadePointEyf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3240+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $810, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl12addFadePointEyf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl12getMixMatrixEPfPiS2_i
  .p2align 4
  .type _ZN4FMOD14ChannelControl12getMixMatrixEPfPiS2_i, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl12getMixMatrixEPfPiS2_i
#endif
_ZN4FMOD14ChannelControl12getMixMatrixEPfPiS2_i:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3244+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $811, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl12getMixMatrixEPfPiS2_i
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl12setMixMatrixEPfiii
  .p2align 4
  .type _ZN4FMOD14ChannelControl12setMixMatrixEPfiii, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl12setMixMatrixEPfiii
#endif
_ZN4FMOD14ChannelControl12setMixMatrixEPfiii:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3248+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $812, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl12setMixMatrixEPfiii
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl13getAudibilityEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl13getAudibilityEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl13getAudibilityEPf
#endif
_ZN4FMOD14ChannelControl13getAudibilityEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3252+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $813, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl13getAudibilityEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl13getFadePointsEPjPyPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl13getFadePointsEPjPyPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl13getFadePointsEPjPyPf
#endif
_ZN4FMOD14ChannelControl13getFadePointsEPjPyPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3256+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $814, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl13getFadePointsEPjPyPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl13getVolumeRampEPb
  .p2align 4
  .type _ZN4FMOD14ChannelControl13getVolumeRampEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl13getVolumeRampEPb
#endif
_ZN4FMOD14ChannelControl13getVolumeRampEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3260+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $815, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl13getVolumeRampEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl13setVolumeRampEb
  .p2align 4
  .type _ZN4FMOD14ChannelControl13setVolumeRampEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl13setVolumeRampEb
#endif
_ZN4FMOD14ChannelControl13setVolumeRampEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3264+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $816, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl13setVolumeRampEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl14get3DOcclusionEPfS1_
  .p2align 4
  .type _ZN4FMOD14ChannelControl14get3DOcclusionEPfS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl14get3DOcclusionEPfS1_
#endif
_ZN4FMOD14ChannelControl14get3DOcclusionEPfS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3268+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $817, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl14get3DOcclusionEPfS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl14getLowPassGainEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl14getLowPassGainEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl14getLowPassGainEPf
#endif
_ZN4FMOD14ChannelControl14getLowPassGainEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3272+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $818, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl14getLowPassGainEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl14set3DOcclusionEff
  .p2align 4
  .type _ZN4FMOD14ChannelControl14set3DOcclusionEff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl14set3DOcclusionEff
#endif
_ZN4FMOD14ChannelControl14set3DOcclusionEff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3276+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $819, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl14set3DOcclusionEff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl14setLowPassGainEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl14setLowPassGainEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl14setLowPassGainEf
#endif
_ZN4FMOD14ChannelControl14setLowPassGainEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3280+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $820, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl14setLowPassGainEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl15get3DAttributesEP11FMOD_VECTORS2_
  .p2align 4
  .type _ZN4FMOD14ChannelControl15get3DAttributesEP11FMOD_VECTORS2_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl15get3DAttributesEP11FMOD_VECTORS2_
#endif
_ZN4FMOD14ChannelControl15get3DAttributesEP11FMOD_VECTORS2_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3284+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $821, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl15get3DAttributesEP11FMOD_VECTORS2_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl15getSystemObjectEPPNS_6SystemE
  .p2align 4
  .type _ZN4FMOD14ChannelControl15getSystemObjectEPPNS_6SystemE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl15getSystemObjectEPPNS_6SystemE
#endif
_ZN4FMOD14ChannelControl15getSystemObjectEPPNS_6SystemE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3288+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $822, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl15getSystemObjectEPPNS_6SystemE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl15set3DAttributesEPK11FMOD_VECTORS3_
  .p2align 4
  .type _ZN4FMOD14ChannelControl15set3DAttributesEPK11FMOD_VECTORS3_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl15set3DAttributesEPK11FMOD_VECTORS3_
#endif
_ZN4FMOD14ChannelControl15set3DAttributesEPK11FMOD_VECTORS3_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3292+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $823, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl15set3DAttributesEPK11FMOD_VECTORS3_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl16removeFadePointsEyy
  .p2align 4
  .type _ZN4FMOD14ChannelControl16removeFadePointsEyy, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl16removeFadePointsEyy
#endif
_ZN4FMOD14ChannelControl16removeFadePointsEyy:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3296+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $824, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl16removeFadePointsEyy
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl16setFadePointRampEyf
  .p2align 4
  .type _ZN4FMOD14ChannelControl16setFadePointRampEyf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl16setFadePointRampEyf
#endif
_ZN4FMOD14ChannelControl16setFadePointRampEyf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3300+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $825, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl16setFadePointRampEyf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl17get3DConeSettingsEPfS1_S1_
  .p2align 4
  .type _ZN4FMOD14ChannelControl17get3DConeSettingsEPfS1_S1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl17get3DConeSettingsEPfS1_S1_
#endif
_ZN4FMOD14ChannelControl17get3DConeSettingsEPfS1_S1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3304+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $826, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl17get3DConeSettingsEPfS1_S1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl17get3DDopplerLevelEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl17get3DDopplerLevelEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl17get3DDopplerLevelEPf
#endif
_ZN4FMOD14ChannelControl17get3DDopplerLevelEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3308+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $827, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl17get3DDopplerLevelEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl17set3DConeSettingsEfff
  .p2align 4
  .type _ZN4FMOD14ChannelControl17set3DConeSettingsEfff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl17set3DConeSettingsEfff
#endif
_ZN4FMOD14ChannelControl17set3DConeSettingsEfff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3312+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $828, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl17set3DConeSettingsEfff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl17set3DDopplerLevelEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl17set3DDopplerLevelEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl17set3DDopplerLevelEf
#endif
_ZN4FMOD14ChannelControl17set3DDopplerLevelEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3316+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $829, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl17set3DDopplerLevelEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl17setMixLevelsInputEPfi
  .p2align 4
  .type _ZN4FMOD14ChannelControl17setMixLevelsInputEPfi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl17setMixLevelsInputEPfi
#endif
_ZN4FMOD14ChannelControl17setMixLevelsInputEPfi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3320+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $830, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl17setMixLevelsInputEPfi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl18get3DCustomRolloffEPP11FMOD_VECTORPi
  .p2align 4
  .type _ZN4FMOD14ChannelControl18get3DCustomRolloffEPP11FMOD_VECTORPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl18get3DCustomRolloffEPP11FMOD_VECTORPi
#endif
_ZN4FMOD14ChannelControl18get3DCustomRolloffEPP11FMOD_VECTORPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3324+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $831, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl18get3DCustomRolloffEPP11FMOD_VECTORPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl18set3DCustomRolloffEP11FMOD_VECTORi
  .p2align 4
  .type _ZN4FMOD14ChannelControl18set3DCustomRolloffEP11FMOD_VECTORi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl18set3DCustomRolloffEP11FMOD_VECTORi
#endif
_ZN4FMOD14ChannelControl18set3DCustomRolloffEP11FMOD_VECTORi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3328+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $832, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl18set3DCustomRolloffEP11FMOD_VECTORi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl18setMixLevelsOutputEffffffff
  .p2align 4
  .type _ZN4FMOD14ChannelControl18setMixLevelsOutputEffffffff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl18setMixLevelsOutputEffffffff
#endif
_ZN4FMOD14ChannelControl18setMixLevelsOutputEffffffff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3332+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $833, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl18setMixLevelsOutputEffffffff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl19get3DDistanceFilterEPbPfS2_
  .p2align 4
  .type _ZN4FMOD14ChannelControl19get3DDistanceFilterEPbPfS2_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl19get3DDistanceFilterEPbPfS2_
#endif
_ZN4FMOD14ChannelControl19get3DDistanceFilterEPbPfS2_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3336+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $834, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl19get3DDistanceFilterEPbPfS2_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl19get3DMinMaxDistanceEPfS1_
  .p2align 4
  .type _ZN4FMOD14ChannelControl19get3DMinMaxDistanceEPfS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl19get3DMinMaxDistanceEPfS1_
#endif
_ZN4FMOD14ChannelControl19get3DMinMaxDistanceEPfS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3340+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $835, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl19get3DMinMaxDistanceEPfS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl19getReverbPropertiesEiPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl19getReverbPropertiesEiPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl19getReverbPropertiesEiPf
#endif
_ZN4FMOD14ChannelControl19getReverbPropertiesEiPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3344+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $836, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl19getReverbPropertiesEiPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl19set3DDistanceFilterEbff
  .p2align 4
  .type _ZN4FMOD14ChannelControl19set3DDistanceFilterEbff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl19set3DDistanceFilterEbff
#endif
_ZN4FMOD14ChannelControl19set3DDistanceFilterEbff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3348+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $837, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl19set3DDistanceFilterEbff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl19set3DMinMaxDistanceEff
  .p2align 4
  .type _ZN4FMOD14ChannelControl19set3DMinMaxDistanceEff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl19set3DMinMaxDistanceEff
#endif
_ZN4FMOD14ChannelControl19set3DMinMaxDistanceEff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3352+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $838, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl19set3DMinMaxDistanceEff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl19setReverbPropertiesEif
  .p2align 4
  .type _ZN4FMOD14ChannelControl19setReverbPropertiesEif, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl19setReverbPropertiesEif
#endif
_ZN4FMOD14ChannelControl19setReverbPropertiesEif:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3356+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $839, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl19setReverbPropertiesEif
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl20get3DConeOrientationEP11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD14ChannelControl20get3DConeOrientationEP11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl20get3DConeOrientationEP11FMOD_VECTOR
#endif
_ZN4FMOD14ChannelControl20get3DConeOrientationEP11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3360+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $840, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl20get3DConeOrientationEP11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl20set3DConeOrientationEP11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD14ChannelControl20set3DConeOrientationEP11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl20set3DConeOrientationEP11FMOD_VECTOR
#endif
_ZN4FMOD14ChannelControl20set3DConeOrientationEP11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3364+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $841, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl20set3DConeOrientationEP11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl4stopEv
  .p2align 4
  .type _ZN4FMOD14ChannelControl4stopEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl4stopEv
#endif
_ZN4FMOD14ChannelControl4stopEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3368+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $842, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl4stopEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl6addDSPEiPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD14ChannelControl6addDSPEiPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl6addDSPEiPNS_3DSPE
#endif
_ZN4FMOD14ChannelControl6addDSPEiPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3372+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $843, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl6addDSPEiPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl6getDSPEiPPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD14ChannelControl6getDSPEiPPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl6getDSPEiPPNS_3DSPE
#endif
_ZN4FMOD14ChannelControl6getDSPEiPPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3376+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $844, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl6getDSPEiPPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl6setPanEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl6setPanEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl6setPanEf
#endif
_ZN4FMOD14ChannelControl6setPanEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3380+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $845, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl6setPanEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl7getModeEPj
  .p2align 4
  .type _ZN4FMOD14ChannelControl7getModeEPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl7getModeEPj
#endif
_ZN4FMOD14ChannelControl7getModeEPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3384+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $846, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl7getModeEPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl7getMuteEPb
  .p2align 4
  .type _ZN4FMOD14ChannelControl7getMuteEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl7getMuteEPb
#endif
_ZN4FMOD14ChannelControl7getMuteEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3388+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $847, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl7getMuteEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl7setModeEj
  .p2align 4
  .type _ZN4FMOD14ChannelControl7setModeEj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl7setModeEj
#endif
_ZN4FMOD14ChannelControl7setModeEj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3392+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $848, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl7setModeEj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl7setMuteEb
  .p2align 4
  .type _ZN4FMOD14ChannelControl7setMuteEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl7setMuteEb
#endif
_ZN4FMOD14ChannelControl7setMuteEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3396+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $849, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl7setMuteEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl8getDelayEPyS1_Pb
  .p2align 4
  .type _ZN4FMOD14ChannelControl8getDelayEPyS1_Pb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl8getDelayEPyS1_Pb
#endif
_ZN4FMOD14ChannelControl8getDelayEPyS1_Pb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3400+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $850, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl8getDelayEPyS1_Pb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl8getPitchEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl8getPitchEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl8getPitchEPf
#endif
_ZN4FMOD14ChannelControl8getPitchEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3404+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $851, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl8getPitchEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl8setDelayEyyb
  .p2align 4
  .type _ZN4FMOD14ChannelControl8setDelayEyyb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl8setDelayEyyb
#endif
_ZN4FMOD14ChannelControl8setDelayEyyb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3408+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $852, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl8setDelayEyyb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl8setPitchEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl8setPitchEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl8setPitchEf
#endif
_ZN4FMOD14ChannelControl8setPitchEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3412+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $853, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl8setPitchEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl9getPausedEPb
  .p2align 4
  .type _ZN4FMOD14ChannelControl9getPausedEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl9getPausedEPb
#endif
_ZN4FMOD14ChannelControl9getPausedEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3416+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $854, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl9getPausedEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl9getVolumeEPf
  .p2align 4
  .type _ZN4FMOD14ChannelControl9getVolumeEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl9getVolumeEPf
#endif
_ZN4FMOD14ChannelControl9getVolumeEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3420+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $855, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl9getVolumeEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl9isPlayingEPb
  .p2align 4
  .type _ZN4FMOD14ChannelControl9isPlayingEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl9isPlayingEPb
#endif
_ZN4FMOD14ChannelControl9isPlayingEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3424+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $856, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl9isPlayingEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl9removeDSPEPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD14ChannelControl9removeDSPEPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl9removeDSPEPNS_3DSPE
#endif
_ZN4FMOD14ChannelControl9removeDSPEPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3428+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $857, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl9removeDSPEPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl9setPausedEb
  .p2align 4
  .type _ZN4FMOD14ChannelControl9setPausedEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl9setPausedEb
#endif
_ZN4FMOD14ChannelControl9setPausedEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3432+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $858, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl9setPausedEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD14ChannelControl9setVolumeEf
  .p2align 4
  .type _ZN4FMOD14ChannelControl9setVolumeEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD14ChannelControl9setVolumeEf
#endif
_ZN4FMOD14ChannelControl9setVolumeEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3436+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $859, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD14ChannelControl9setVolumeEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP11getCPUUsageEPjS1_
  .p2align 4
  .type _ZN4FMOD3DSP11getCPUUsageEPjS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP11getCPUUsageEPjS1_
#endif
_ZN4FMOD3DSP11getCPUUsageEPjS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3440+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $860, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP11getCPUUsageEPjS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD3DSP11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP11getUserDataEPPv
#endif
_ZN4FMOD3DSP11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3444+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $861, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD3DSP11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP11setUserDataEPv
#endif
_ZN4FMOD3DSP11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3448+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $862, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP12getNumInputsEPi
  .p2align 4
  .type _ZN4FMOD3DSP12getNumInputsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP12getNumInputsEPi
#endif
_ZN4FMOD3DSP12getNumInputsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3452+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $863, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP12getNumInputsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP12getWetDryMixEPfS1_S1_
  .p2align 4
  .type _ZN4FMOD3DSP12getWetDryMixEPfS1_S1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP12getWetDryMixEPfS1_S1_
#endif
_ZN4FMOD3DSP12getWetDryMixEPfS1_S1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3456+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $864, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP12getWetDryMixEPfS1_S1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP12setWetDryMixEfff
  .p2align 4
  .type _ZN4FMOD3DSP12setWetDryMixEfff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP12setWetDryMixEfff
#endif
_ZN4FMOD3DSP12setWetDryMixEfff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3460+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $865, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP12setWetDryMixEfff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP13disconnectAllEbb
  .p2align 4
  .type _ZN4FMOD3DSP13disconnectAllEbb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP13disconnectAllEbb
#endif
_ZN4FMOD3DSP13disconnectAllEbb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3464+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $866, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP13disconnectAllEbb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP13getNumOutputsEPi
  .p2align 4
  .type _ZN4FMOD3DSP13getNumOutputsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP13getNumOutputsEPi
#endif
_ZN4FMOD3DSP13getNumOutputsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3468+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $867, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP13getNumOutputsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP14disconnectFromEPS0_PNS_13DSPConnectionE
  .p2align 4
  .type _ZN4FMOD3DSP14disconnectFromEPS0_PNS_13DSPConnectionE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP14disconnectFromEPS0_PNS_13DSPConnectionE
#endif
_ZN4FMOD3DSP14disconnectFromEPS0_PNS_13DSPConnectionE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3472+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $868, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP14disconnectFromEPS0_PNS_13DSPConnectionE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP15getMeteringInfoEP22FMOD_DSP_METERING_INFOS2_
  .p2align 4
  .type _ZN4FMOD3DSP15getMeteringInfoEP22FMOD_DSP_METERING_INFOS2_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP15getMeteringInfoEP22FMOD_DSP_METERING_INFOS2_
#endif
_ZN4FMOD3DSP15getMeteringInfoEP22FMOD_DSP_METERING_INFOS2_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3476+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $869, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP15getMeteringInfoEP22FMOD_DSP_METERING_INFOS2_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP15getParameterIntEiPiPci
  .p2align 4
  .type _ZN4FMOD3DSP15getParameterIntEiPiPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP15getParameterIntEiPiPci
#endif
_ZN4FMOD3DSP15getParameterIntEiPiPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3480+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $870, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP15getParameterIntEiPiPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP15getSystemObjectEPPNS_6SystemE
  .p2align 4
  .type _ZN4FMOD3DSP15getSystemObjectEPPNS_6SystemE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP15getSystemObjectEPPNS_6SystemE
#endif
_ZN4FMOD3DSP15getSystemObjectEPPNS_6SystemE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3484+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $871, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP15getSystemObjectEPPNS_6SystemE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP15setParameterIntEii
  .p2align 4
  .type _ZN4FMOD3DSP15setParameterIntEii, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP15setParameterIntEii
#endif
_ZN4FMOD3DSP15setParameterIntEii:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3488+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $872, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP15setParameterIntEii
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16getChannelFormatEPjPiP16FMOD_SPEAKERMODE
  .p2align 4
  .type _ZN4FMOD3DSP16getChannelFormatEPjPiP16FMOD_SPEAKERMODE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16getChannelFormatEPjPiP16FMOD_SPEAKERMODE
#endif
_ZN4FMOD3DSP16getChannelFormatEPjPiP16FMOD_SPEAKERMODE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3492+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $873, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16getChannelFormatEPjPiP16FMOD_SPEAKERMODE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16getNumParametersEPi
  .p2align 4
  .type _ZN4FMOD3DSP16getNumParametersEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16getNumParametersEPi
#endif
_ZN4FMOD3DSP16getNumParametersEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3496+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $874, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16getNumParametersEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16getParameterBoolEiPbPci
  .p2align 4
  .type _ZN4FMOD3DSP16getParameterBoolEiPbPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16getParameterBoolEiPbPci
#endif
_ZN4FMOD3DSP16getParameterBoolEiPbPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3500+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $875, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16getParameterBoolEiPbPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16getParameterDataEiPPvPjPci
  .p2align 4
  .type _ZN4FMOD3DSP16getParameterDataEiPPvPjPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16getParameterDataEiPPvPjPci
#endif
_ZN4FMOD3DSP16getParameterDataEiPPvPjPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3504+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $876, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16getParameterDataEiPPvPjPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16getParameterInfoEiPP23FMOD_DSP_PARAMETER_DESC
  .p2align 4
  .type _ZN4FMOD3DSP16getParameterInfoEiPP23FMOD_DSP_PARAMETER_DESC, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16getParameterInfoEiPP23FMOD_DSP_PARAMETER_DESC
#endif
_ZN4FMOD3DSP16getParameterInfoEiPP23FMOD_DSP_PARAMETER_DESC:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3508+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $877, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16getParameterInfoEiPP23FMOD_DSP_PARAMETER_DESC
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16setChannelFormatEji16FMOD_SPEAKERMODE
  .p2align 4
  .type _ZN4FMOD3DSP16setChannelFormatEji16FMOD_SPEAKERMODE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16setChannelFormatEji16FMOD_SPEAKERMODE
#endif
_ZN4FMOD3DSP16setChannelFormatEji16FMOD_SPEAKERMODE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3512+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $878, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16setChannelFormatEji16FMOD_SPEAKERMODE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16setParameterBoolEib
  .p2align 4
  .type _ZN4FMOD3DSP16setParameterBoolEib, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16setParameterBoolEib
#endif
_ZN4FMOD3DSP16setParameterBoolEib:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3516+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $879, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16setParameterBoolEib
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16setParameterDataEiPvj
  .p2align 4
  .type _ZN4FMOD3DSP16setParameterDataEiPvj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16setParameterDataEiPvj
#endif
_ZN4FMOD3DSP16setParameterDataEiPvj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3520+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $880, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16setParameterDataEiPvj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP16showConfigDialogEPvb
  .p2align 4
  .type _ZN4FMOD3DSP16showConfigDialogEPvb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP16showConfigDialogEPvb
#endif
_ZN4FMOD3DSP16showConfigDialogEPvb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3524+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $881, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP16showConfigDialogEPvb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP17getParameterFloatEiPfPci
  .p2align 4
  .type _ZN4FMOD3DSP17getParameterFloatEiPfPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP17getParameterFloatEiPfPci
#endif
_ZN4FMOD3DSP17getParameterFloatEiPfPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3528+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $882, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP17getParameterFloatEiPfPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP17setParameterFloatEif
  .p2align 4
  .type _ZN4FMOD3DSP17setParameterFloatEif, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP17setParameterFloatEif
#endif
_ZN4FMOD3DSP17setParameterFloatEif:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3532+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $883, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP17setParameterFloatEif
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP18getMeteringEnabledEPbS1_
  .p2align 4
  .type _ZN4FMOD3DSP18getMeteringEnabledEPbS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP18getMeteringEnabledEPbS1_
#endif
_ZN4FMOD3DSP18getMeteringEnabledEPbS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3536+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $884, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP18getMeteringEnabledEPbS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP18setMeteringEnabledEbb
  .p2align 4
  .type _ZN4FMOD3DSP18setMeteringEnabledEbb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP18setMeteringEnabledEbb
#endif
_ZN4FMOD3DSP18setMeteringEnabledEbb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3540+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $885, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP18setMeteringEnabledEbb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP21getDataParameterIndexEiPi
  .p2align 4
  .type _ZN4FMOD3DSP21getDataParameterIndexEiPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP21getDataParameterIndexEiPi
#endif
_ZN4FMOD3DSP21getDataParameterIndexEiPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3544+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $886, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP21getDataParameterIndexEiPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP22getOutputChannelFormatEji16FMOD_SPEAKERMODEPjPiPS1_
  .p2align 4
  .type _ZN4FMOD3DSP22getOutputChannelFormatEji16FMOD_SPEAKERMODEPjPiPS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP22getOutputChannelFormatEji16FMOD_SPEAKERMODEPjPiPS1_
#endif
_ZN4FMOD3DSP22getOutputChannelFormatEji16FMOD_SPEAKERMODEPjPiPS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3548+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $887, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP22getOutputChannelFormatEji16FMOD_SPEAKERMODEPjPiPS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP5resetEv
  .p2align 4
  .type _ZN4FMOD3DSP5resetEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP5resetEv
#endif
_ZN4FMOD3DSP5resetEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3552+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $888, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP5resetEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP7getIdleEPb
  .p2align 4
  .type _ZN4FMOD3DSP7getIdleEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP7getIdleEPb
#endif
_ZN4FMOD3DSP7getIdleEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3556+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $889, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP7getIdleEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP7getInfoEPcPjPiS3_S3_
  .p2align 4
  .type _ZN4FMOD3DSP7getInfoEPcPjPiS3_S3_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP7getInfoEPcPjPiS3_S3_
#endif
_ZN4FMOD3DSP7getInfoEPcPjPiS3_S3_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3560+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $890, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP7getInfoEPcPjPiS3_S3_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP7getTypeEP13FMOD_DSP_TYPE
  .p2align 4
  .type _ZN4FMOD3DSP7getTypeEP13FMOD_DSP_TYPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP7getTypeEP13FMOD_DSP_TYPE
#endif
_ZN4FMOD3DSP7getTypeEP13FMOD_DSP_TYPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3564+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $891, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP7getTypeEP13FMOD_DSP_TYPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP7releaseEv
  .p2align 4
  .type _ZN4FMOD3DSP7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP7releaseEv
#endif
_ZN4FMOD3DSP7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3568+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $892, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP8addInputEPS0_PPNS_13DSPConnectionE23FMOD_DSPCONNECTION_TYPE
  .p2align 4
  .type _ZN4FMOD3DSP8addInputEPS0_PPNS_13DSPConnectionE23FMOD_DSPCONNECTION_TYPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP8addInputEPS0_PPNS_13DSPConnectionE23FMOD_DSPCONNECTION_TYPE
#endif
_ZN4FMOD3DSP8addInputEPS0_PPNS_13DSPConnectionE23FMOD_DSPCONNECTION_TYPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3572+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $893, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP8addInputEPS0_PPNS_13DSPConnectionE23FMOD_DSPCONNECTION_TYPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP8getInputEiPPS0_PPNS_13DSPConnectionE
  .p2align 4
  .type _ZN4FMOD3DSP8getInputEiPPS0_PPNS_13DSPConnectionE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP8getInputEiPPS0_PPNS_13DSPConnectionE
#endif
_ZN4FMOD3DSP8getInputEiPPS0_PPNS_13DSPConnectionE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3576+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $894, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP8getInputEiPPS0_PPNS_13DSPConnectionE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP9getActiveEPb
  .p2align 4
  .type _ZN4FMOD3DSP9getActiveEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP9getActiveEPb
#endif
_ZN4FMOD3DSP9getActiveEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3580+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $895, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP9getActiveEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP9getBypassEPb
  .p2align 4
  .type _ZN4FMOD3DSP9getBypassEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP9getBypassEPb
#endif
_ZN4FMOD3DSP9getBypassEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3584+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $896, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP9getBypassEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP9getOutputEiPPS0_PPNS_13DSPConnectionE
  .p2align 4
  .type _ZN4FMOD3DSP9getOutputEiPPS0_PPNS_13DSPConnectionE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP9getOutputEiPPS0_PPNS_13DSPConnectionE
#endif
_ZN4FMOD3DSP9getOutputEiPPS0_PPNS_13DSPConnectionE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3588+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $897, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP9getOutputEiPPS0_PPNS_13DSPConnectionE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP9setActiveEb
  .p2align 4
  .type _ZN4FMOD3DSP9setActiveEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP9setActiveEb
#endif
_ZN4FMOD3DSP9setActiveEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3592+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $898, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP9setActiveEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD3DSP9setBypassEb
  .p2align 4
  .type _ZN4FMOD3DSP9setBypassEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD3DSP9setBypassEb
#endif
_ZN4FMOD3DSP9setBypassEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3596+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $899, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD3DSP9setBypassEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD4DSPI8validateEPNS_3DSPEPPS0_PNS_15SystemLockScopeE
  .p2align 4
  .type _ZN4FMOD4DSPI8validateEPNS_3DSPEPPS0_PNS_15SystemLockScopeE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD4DSPI8validateEPNS_3DSPEPPS0_PNS_15SystemLockScopeE
#endif
_ZN4FMOD4DSPI8validateEPNS_3DSPEPPS0_PNS_15SystemLockScopeE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3600+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $900, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD4DSPI8validateEPNS_3DSPEPPS0_PNS_15SystemLockScopeE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound10getNumTagsEPiS1_
  .p2align 4
  .type _ZN4FMOD5Sound10getNumTagsEPiS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound10getNumTagsEPiS1_
#endif
_ZN4FMOD5Sound10getNumTagsEPiS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3604+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $901, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound10getNumTagsEPiS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound11getDefaultsEPfPi
  .p2align 4
  .type _ZN4FMOD5Sound11getDefaultsEPfPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound11getDefaultsEPfPi
#endif
_ZN4FMOD5Sound11getDefaultsEPfPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3608+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $902, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound11getDefaultsEPfPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound11getSubSoundEiPPS0_
  .p2align 4
  .type _ZN4FMOD5Sound11getSubSoundEiPPS0_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound11getSubSoundEiPPS0_
#endif
_ZN4FMOD5Sound11getSubSoundEiPPS0_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3612+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $903, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound11getSubSoundEiPPS0_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD5Sound11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound11getUserDataEPPv
#endif
_ZN4FMOD5Sound11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3616+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $904, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound11setDefaultsEfi
  .p2align 4
  .type _ZN4FMOD5Sound11setDefaultsEfi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound11setDefaultsEfi
#endif
_ZN4FMOD5Sound11setDefaultsEfi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3620+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $905, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound11setDefaultsEfi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD5Sound11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound11setUserDataEPv
#endif
_ZN4FMOD5Sound11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3624+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $906, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound12addSyncPointEjjPKcPP14FMOD_SYNCPOINT
  .p2align 4
  .type _ZN4FMOD5Sound12addSyncPointEjjPKcPP14FMOD_SYNCPOINT, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound12addSyncPointEjjPKcPP14FMOD_SYNCPOINT
#endif
_ZN4FMOD5Sound12addSyncPointEjjPKcPP14FMOD_SYNCPOINT:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3628+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $907, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound12addSyncPointEjjPKcPP14FMOD_SYNCPOINT
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound12getLoopCountEPi
  .p2align 4
  .type _ZN4FMOD5Sound12getLoopCountEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound12getLoopCountEPi
#endif
_ZN4FMOD5Sound12getLoopCountEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3632+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $908, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound12getLoopCountEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound12getOpenStateEP14FMOD_OPENSTATEPjPbS4_
  .p2align 4
  .type _ZN4FMOD5Sound12getOpenStateEP14FMOD_OPENSTATEPjPbS4_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound12getOpenStateEP14FMOD_OPENSTATEPjPbS4_
#endif
_ZN4FMOD5Sound12getOpenStateEP14FMOD_OPENSTATEPjPbS4_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3636+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $909, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound12getOpenStateEP14FMOD_OPENSTATEPjPbS4_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound12getSyncPointEiPP14FMOD_SYNCPOINT
  .p2align 4
  .type _ZN4FMOD5Sound12getSyncPointEiPP14FMOD_SYNCPOINT, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound12getSyncPointEiPP14FMOD_SYNCPOINT
#endif
_ZN4FMOD5Sound12getSyncPointEiPP14FMOD_SYNCPOINT:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3640+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $910, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound12getSyncPointEiPP14FMOD_SYNCPOINT
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound12setLoopCountEi
  .p2align 4
  .type _ZN4FMOD5Sound12setLoopCountEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound12setLoopCountEi
#endif
_ZN4FMOD5Sound12setLoopCountEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3644+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $911, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound12setLoopCountEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound13getLoopPointsEPjjS1_j
  .p2align 4
  .type _ZN4FMOD5Sound13getLoopPointsEPjjS1_j, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound13getLoopPointsEPjjS1_j
#endif
_ZN4FMOD5Sound13getLoopPointsEPjjS1_j:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3648+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $912, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound13getLoopPointsEPjjS1_j
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound13getMusicSpeedEPf
  .p2align 4
  .type _ZN4FMOD5Sound13getMusicSpeedEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound13getMusicSpeedEPf
#endif
_ZN4FMOD5Sound13getMusicSpeedEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3652+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $913, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound13getMusicSpeedEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound13getSoundGroupEPPNS_10SoundGroupE
  .p2align 4
  .type _ZN4FMOD5Sound13getSoundGroupEPPNS_10SoundGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound13getSoundGroupEPPNS_10SoundGroupE
#endif
_ZN4FMOD5Sound13getSoundGroupEPPNS_10SoundGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3656+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $914, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound13getSoundGroupEPPNS_10SoundGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound13setLoopPointsEjjjj
  .p2align 4
  .type _ZN4FMOD5Sound13setLoopPointsEjjjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound13setLoopPointsEjjjj
#endif
_ZN4FMOD5Sound13setLoopPointsEjjjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3660+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $915, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound13setLoopPointsEjjjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound13setMusicSpeedEf
  .p2align 4
  .type _ZN4FMOD5Sound13setMusicSpeedEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound13setMusicSpeedEf
#endif
_ZN4FMOD5Sound13setMusicSpeedEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3664+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $916, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound13setMusicSpeedEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound13setSoundGroupEPNS_10SoundGroupE
  .p2align 4
  .type _ZN4FMOD5Sound13setSoundGroupEPNS_10SoundGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound13setSoundGroupEPNS_10SoundGroupE
#endif
_ZN4FMOD5Sound13setSoundGroupEPNS_10SoundGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3668+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $917, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound13setSoundGroupEPNS_10SoundGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound15deleteSyncPointEP14FMOD_SYNCPOINT
  .p2align 4
  .type _ZN4FMOD5Sound15deleteSyncPointEP14FMOD_SYNCPOINT, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound15deleteSyncPointEP14FMOD_SYNCPOINT
#endif
_ZN4FMOD5Sound15deleteSyncPointEP14FMOD_SYNCPOINT:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3672+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $918, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound15deleteSyncPointEP14FMOD_SYNCPOINT
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound15getNumSubSoundsEPi
  .p2align 4
  .type _ZN4FMOD5Sound15getNumSubSoundsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound15getNumSubSoundsEPi
#endif
_ZN4FMOD5Sound15getNumSubSoundsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3676+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $919, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound15getNumSubSoundsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound15getSystemObjectEPPNS_6SystemE
  .p2align 4
  .type _ZN4FMOD5Sound15getSystemObjectEPPNS_6SystemE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound15getSystemObjectEPPNS_6SystemE
#endif
_ZN4FMOD5Sound15getSystemObjectEPPNS_6SystemE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3680+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $920, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound15getSystemObjectEPPNS_6SystemE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound16getNumSyncPointsEPi
  .p2align 4
  .type _ZN4FMOD5Sound16getNumSyncPointsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound16getNumSyncPointsEPi
#endif
_ZN4FMOD5Sound16getNumSyncPointsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3684+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $921, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound16getNumSyncPointsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound16getSyncPointInfoEP14FMOD_SYNCPOINTPciPjj
  .p2align 4
  .type _ZN4FMOD5Sound16getSyncPointInfoEP14FMOD_SYNCPOINTPciPjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound16getSyncPointInfoEP14FMOD_SYNCPOINTPciPjj
#endif
_ZN4FMOD5Sound16getSyncPointInfoEP14FMOD_SYNCPOINTPciPjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3688+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $922, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound16getSyncPointInfoEP14FMOD_SYNCPOINTPciPjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound17get3DConeSettingsEPfS1_S1_
  .p2align 4
  .type _ZN4FMOD5Sound17get3DConeSettingsEPfS1_S1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound17get3DConeSettingsEPfS1_S1_
#endif
_ZN4FMOD5Sound17get3DConeSettingsEPfS1_S1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3692+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $923, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound17get3DConeSettingsEPfS1_S1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound17getSubSoundParentEPPS0_
  .p2align 4
  .type _ZN4FMOD5Sound17getSubSoundParentEPPS0_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound17getSubSoundParentEPPS0_
#endif
_ZN4FMOD5Sound17getSubSoundParentEPPS0_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3696+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $924, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound17getSubSoundParentEPPS0_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound17set3DConeSettingsEfff
  .p2align 4
  .type _ZN4FMOD5Sound17set3DConeSettingsEfff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound17set3DConeSettingsEfff
#endif
_ZN4FMOD5Sound17set3DConeSettingsEfff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3700+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $925, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound17set3DConeSettingsEfff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound18get3DCustomRolloffEPP11FMOD_VECTORPi
  .p2align 4
  .type _ZN4FMOD5Sound18get3DCustomRolloffEPP11FMOD_VECTORPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound18get3DCustomRolloffEPP11FMOD_VECTORPi
#endif
_ZN4FMOD5Sound18get3DCustomRolloffEPP11FMOD_VECTORPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3704+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $926, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound18get3DCustomRolloffEPP11FMOD_VECTORPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound18set3DCustomRolloffEP11FMOD_VECTORi
  .p2align 4
  .type _ZN4FMOD5Sound18set3DCustomRolloffEP11FMOD_VECTORi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound18set3DCustomRolloffEP11FMOD_VECTORi
#endif
_ZN4FMOD5Sound18set3DCustomRolloffEP11FMOD_VECTORi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3708+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $927, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound18set3DCustomRolloffEP11FMOD_VECTORi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound19get3DMinMaxDistanceEPfS1_
  .p2align 4
  .type _ZN4FMOD5Sound19get3DMinMaxDistanceEPfS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound19get3DMinMaxDistanceEPfS1_
#endif
_ZN4FMOD5Sound19get3DMinMaxDistanceEPfS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3712+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $928, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound19get3DMinMaxDistanceEPfS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound19getMusicNumChannelsEPi
  .p2align 4
  .type _ZN4FMOD5Sound19getMusicNumChannelsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound19getMusicNumChannelsEPi
#endif
_ZN4FMOD5Sound19getMusicNumChannelsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3716+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $929, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound19getMusicNumChannelsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound19set3DMinMaxDistanceEff
  .p2align 4
  .type _ZN4FMOD5Sound19set3DMinMaxDistanceEff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound19set3DMinMaxDistanceEff
#endif
_ZN4FMOD5Sound19set3DMinMaxDistanceEff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3720+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $930, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound19set3DMinMaxDistanceEff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound21getMusicChannelVolumeEiPf
  .p2align 4
  .type _ZN4FMOD5Sound21getMusicChannelVolumeEiPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound21getMusicChannelVolumeEiPf
#endif
_ZN4FMOD5Sound21getMusicChannelVolumeEiPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3724+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $931, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound21getMusicChannelVolumeEiPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound21setMusicChannelVolumeEif
  .p2align 4
  .type _ZN4FMOD5Sound21setMusicChannelVolumeEif, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound21setMusicChannelVolumeEif
#endif
_ZN4FMOD5Sound21setMusicChannelVolumeEif:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3728+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $932, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound21setMusicChannelVolumeEif
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound4lockEjjPPvS2_PjS3_
  .p2align 4
  .type _ZN4FMOD5Sound4lockEjjPPvS2_PjS3_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound4lockEjjPPvS2_PjS3_
#endif
_ZN4FMOD5Sound4lockEjjPPvS2_PjS3_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3732+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $933, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound4lockEjjPPvS2_PjS3_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound6getTagEPKciP8FMOD_TAG
  .p2align 4
  .type _ZN4FMOD5Sound6getTagEPKciP8FMOD_TAG, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound6getTagEPKciP8FMOD_TAG
#endif
_ZN4FMOD5Sound6getTagEPKciP8FMOD_TAG:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3736+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $934, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound6getTagEPKciP8FMOD_TAG
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound6unlockEPvS1_jj
  .p2align 4
  .type _ZN4FMOD5Sound6unlockEPvS1_jj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound6unlockEPvS1_jj
#endif
_ZN4FMOD5Sound6unlockEPvS1_jj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3740+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $935, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound6unlockEPvS1_jj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound7getModeEPj
  .p2align 4
  .type _ZN4FMOD5Sound7getModeEPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound7getModeEPj
#endif
_ZN4FMOD5Sound7getModeEPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3744+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $936, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound7getModeEPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound7getNameEPci
  .p2align 4
  .type _ZN4FMOD5Sound7getNameEPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound7getNameEPci
#endif
_ZN4FMOD5Sound7getNameEPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3748+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $937, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound7getNameEPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound7releaseEv
  .p2align 4
  .type _ZN4FMOD5Sound7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound7releaseEv
#endif
_ZN4FMOD5Sound7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3752+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $938, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound7setModeEj
  .p2align 4
  .type _ZN4FMOD5Sound7setModeEj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound7setModeEj
#endif
_ZN4FMOD5Sound7setModeEj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3756+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $939, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound7setModeEj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound8readDataEPvjPj
  .p2align 4
  .type _ZN4FMOD5Sound8readDataEPvjPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound8readDataEPvjPj
#endif
_ZN4FMOD5Sound8readDataEPvjPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3760+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $940, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound8readDataEPvjPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound8seekDataEj
  .p2align 4
  .type _ZN4FMOD5Sound8seekDataEj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound8seekDataEj
#endif
_ZN4FMOD5Sound8seekDataEj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3764+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $941, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound8seekDataEj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound9getFormatEP15FMOD_SOUND_TYPEP17FMOD_SOUND_FORMATPiS5_
  .p2align 4
  .type _ZN4FMOD5Sound9getFormatEP15FMOD_SOUND_TYPEP17FMOD_SOUND_FORMATPiS5_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound9getFormatEP15FMOD_SOUND_TYPEP17FMOD_SOUND_FORMATPiS5_
#endif
_ZN4FMOD5Sound9getFormatEP15FMOD_SOUND_TYPEP17FMOD_SOUND_FORMATPiS5_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3768+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $942, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound9getFormatEP15FMOD_SOUND_TYPEP17FMOD_SOUND_FORMATPiS5_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD5Sound9getLengthEPjj
  .p2align 4
  .type _ZN4FMOD5Sound9getLengthEPjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD5Sound9getLengthEPjj
#endif
_ZN4FMOD5Sound9getLengthEPjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3772+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $943, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD5Sound9getLengthEPjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6SoundI19getUserDataInternalEPPv
  .p2align 4
  .type _ZN4FMOD6SoundI19getUserDataInternalEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6SoundI19getUserDataInternalEPPv
#endif
_ZN4FMOD6SoundI19getUserDataInternalEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3776+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $944, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6SoundI19getUserDataInternalEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6SoundI19setUserDataInternalEPv
  .p2align 4
  .type _ZN4FMOD6SoundI19setUserDataInternalEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6SoundI19setUserDataInternalEPv
#endif
_ZN4FMOD6SoundI19setUserDataInternalEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3780+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $945, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6SoundI19setUserDataInternalEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System10getChannelEiPPNS_7ChannelE
  .p2align 4
  .type _ZN4FMOD6System10getChannelEiPPNS_7ChannelE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System10getChannelEiPPNS_7ChannelE
#endif
_ZN4FMOD6System10getChannelEiPPNS_7ChannelE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3784+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $946, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System10getChannelEiPPNS_7ChannelE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System10getVersionEPj
  .p2align 4
  .type _ZN4FMOD6System10getVersionEPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System10getVersionEPj
#endif
_ZN4FMOD6System10getVersionEPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3788+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $947, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System10getVersionEPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System10loadPluginEPKcPjj
  .p2align 4
  .type _ZN4FMOD6System10loadPluginEPKcPjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System10loadPluginEPKcPjj
#endif
_ZN4FMOD6System10loadPluginEPKcPjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3792+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $948, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System10loadPluginEPKcPjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System10recordStopEi
  .p2align 4
  .type _ZN4FMOD6System10recordStopEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System10recordStopEi
#endif
_ZN4FMOD6System10recordStopEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3796+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $949, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System10recordStopEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11createSoundEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE
  .p2align 4
  .type _ZN4FMOD6System11createSoundEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11createSoundEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE
#endif
_ZN4FMOD6System11createSoundEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3800+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $950, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11createSoundEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11getCPUUsageEP14FMOD_CPU_USAGE
  .p2align 4
  .type _ZN4FMOD6System11getCPUUsageEP14FMOD_CPU_USAGE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11getCPUUsageEP14FMOD_CPU_USAGE
#endif
_ZN4FMOD6System11getCPUUsageEP14FMOD_CPU_USAGE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3804+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $951, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11getCPUUsageEP14FMOD_CPU_USAGE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD6System11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11getUserDataEPPv
#endif
_ZN4FMOD6System11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3808+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $952, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11isRecordingEiPb
  .p2align 4
  .type _ZN4FMOD6System11isRecordingEiPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11isRecordingEiPb
#endif
_ZN4FMOD6System11isRecordingEiPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3812+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $953, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11isRecordingEiPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11mixerResumeEv
  .p2align 4
  .type _ZN4FMOD6System11mixerResumeEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11mixerResumeEv
#endif
_ZN4FMOD6System11mixerResumeEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3816+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $954, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11mixerResumeEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11recordStartEiPNS_5SoundEb
  .p2align 4
  .type _ZN4FMOD6System11recordStartEiPNS_5SoundEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11recordStartEiPNS_5SoundEb
#endif
_ZN4FMOD6System11recordStartEiPNS_5SoundEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3820+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $955, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11recordStartEiPNS_5SoundEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11registerDSPEPK20FMOD_DSP_DESCRIPTIONPj
  .p2align 4
  .type _ZN4FMOD6System11registerDSPEPK20FMOD_DSP_DESCRIPTIONPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11registerDSPEPK20FMOD_DSP_DESCRIPTIONPj
#endif
_ZN4FMOD6System11registerDSPEPK20FMOD_DSP_DESCRIPTIONPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3824+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $956, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11registerDSPEPK20FMOD_DSP_DESCRIPTIONPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11setCallbackEPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_Ej
  .p2align 4
  .type _ZN4FMOD6System11setCallbackEPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_Ej, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11setCallbackEPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_Ej
#endif
_ZN4FMOD6System11setCallbackEPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_Ej:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3828+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $957, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11setCallbackEPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_Ej
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD6System11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System11setUserDataEPv
#endif
_ZN4FMOD6System11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3832+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $958, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System12createStreamEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE
  .p2align 4
  .type _ZN4FMOD6System12createStreamEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System12createStreamEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE
#endif
_ZN4FMOD6System12createStreamEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3836+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $959, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System12createStreamEPKcjP22FMOD_CREATESOUNDEXINFOPPNS_5SoundE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System12getFileUsageEPxS1_S1_
  .p2align 4
  .type _ZN4FMOD6System12getFileUsageEPxS1_S1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System12getFileUsageEPxS1_S1_
#endif
_ZN4FMOD6System12getFileUsageEPxS1_S1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3840+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $960, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System12getFileUsageEPxS1_S1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System12loadGeometryEPKviPPNS_8GeometryE
  .p2align 4
  .type _ZN4FMOD6System12loadGeometryEPKviPPNS_8GeometryE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System12loadGeometryEPKviPPNS_8GeometryE
#endif
_ZN4FMOD6System12loadGeometryEPKviPPNS_8GeometryE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3844+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $961, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System12loadGeometryEPKviPPNS_8GeometryE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System12mixerSuspendEv
  .p2align 4
  .type _ZN4FMOD6System12mixerSuspendEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System12mixerSuspendEv
#endif
_ZN4FMOD6System12mixerSuspendEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3848+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $962, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System12mixerSuspendEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System12unloadPluginEj
  .p2align 4
  .type _ZN4FMOD6System12unloadPluginEj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System12unloadPluginEj
#endif
_ZN4FMOD6System12unloadPluginEj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3852+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $963, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System12unloadPluginEj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13get3DSettingsEPfS1_S1_
  .p2align 4
  .type _ZN4FMOD6System13get3DSettingsEPfS1_S1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13get3DSettingsEPfS1_S1_
#endif
_ZN4FMOD6System13get3DSettingsEPfS1_S1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3856+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $964, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13get3DSettingsEPfS1_S1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13getDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_
  .p2align 4
  .type _ZN4FMOD6System13getDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13getDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_
#endif
_ZN4FMOD6System13getDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3860+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $965, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13getDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13getNumDriversEPi
  .p2align 4
  .type _ZN4FMOD6System13getNumDriversEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13getNumDriversEPi
#endif
_ZN4FMOD6System13getNumDriversEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3864+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $966, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13getNumDriversEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13getNumPluginsE15FMOD_PLUGINTYPEPi
  .p2align 4
  .type _ZN4FMOD6System13getNumPluginsE15FMOD_PLUGINTYPEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13getNumPluginsE15FMOD_PLUGINTYPEPi
#endif
_ZN4FMOD6System13getNumPluginsE15FMOD_PLUGINTYPEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3868+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $967, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13getNumPluginsE15FMOD_PLUGINTYPEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13getPluginInfoEjP15FMOD_PLUGINTYPEPciPj
  .p2align 4
  .type _ZN4FMOD6System13getPluginInfoEjP15FMOD_PLUGINTYPEPciPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13getPluginInfoEjP15FMOD_PLUGINTYPEPciPj
#endif
_ZN4FMOD6System13getPluginInfoEjP15FMOD_PLUGINTYPEPciPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3872+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $968, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13getPluginInfoEjP15FMOD_PLUGINTYPEPciPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13registerCodecEP22FMOD_CODEC_DESCRIPTIONPjj
  .p2align 4
  .type _ZN4FMOD6System13registerCodecEP22FMOD_CODEC_DESCRIPTIONPjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13registerCodecEP22FMOD_CODEC_DESCRIPTIONPjj
#endif
_ZN4FMOD6System13registerCodecEP22FMOD_CODEC_DESCRIPTIONPjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3876+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $969, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13registerCodecEP22FMOD_CODEC_DESCRIPTIONPjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13set3DSettingsEfff
  .p2align 4
  .type _ZN4FMOD6System13set3DSettingsEfff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13set3DSettingsEfff
#endif
_ZN4FMOD6System13set3DSettingsEfff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3880+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $970, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13set3DSettingsEfff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13setFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_EPFS1_P18FMOD_ASYNCREADINFOS5_ESI_i
  .p2align 4
  .type _ZN4FMOD6System13setFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_EPFS1_P18FMOD_ASYNCREADINFOS5_ESI_i, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13setFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_EPFS1_P18FMOD_ASYNCREADINFOS5_ESI_i
#endif
_ZN4FMOD6System13setFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_EPFS1_P18FMOD_ASYNCREADINFOS5_ESI_i:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3884+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $971, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13setFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_EPFS1_P18FMOD_ASYNCREADINFOS5_ESI_i
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System13setPluginPathEPKc
  .p2align 4
  .type _ZN4FMOD6System13setPluginPathEPKc, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System13setPluginPathEPKc
#endif
_ZN4FMOD6System13setPluginPathEPKc:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3888+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $972, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System13setPluginPathEPKc
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System14createGeometryEiiPPNS_8GeometryE
  .p2align 4
  .type _ZN4FMOD6System14createGeometryEiiPPNS_8GeometryE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System14createGeometryEiiPPNS_8GeometryE
#endif
_ZN4FMOD6System14createGeometryEiiPPNS_8GeometryE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3892+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $973, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System14createGeometryEiiPPNS_8GeometryE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System14createReverb3DEPPNS_8Reverb3DE
  .p2align 4
  .type _ZN4FMOD6System14createReverb3DEPPNS_8Reverb3DE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System14createReverb3DEPPNS_8Reverb3DE
#endif
_ZN4FMOD6System14createReverb3DEPPNS_8Reverb3DE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3896+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $974, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System14createReverb3DEPPNS_8Reverb3DE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System14registerOutputEPK23FMOD_OUTPUT_DESCRIPTIONPj
  .p2align 4
  .type _ZN4FMOD6System14registerOutputEPK23FMOD_OUTPUT_DESCRIPTIONPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System14registerOutputEPK23FMOD_OUTPUT_DESCRIPTIONPj
#endif
_ZN4FMOD6System14registerOutputEPK23FMOD_OUTPUT_DESCRIPTIONPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3900+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $975, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System14registerOutputEPK23FMOD_OUTPUT_DESCRIPTIONPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System15createDSPByTypeE13FMOD_DSP_TYPEPPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD6System15createDSPByTypeE13FMOD_DSP_TYPEPPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System15createDSPByTypeE13FMOD_DSP_TYPEPPNS_3DSPE
#endif
_ZN4FMOD6System15createDSPByTypeE13FMOD_DSP_TYPEPPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3904+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $976, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System15createDSPByTypeE13FMOD_DSP_TYPEPPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System15getNestedPluginEjiPj
  .p2align 4
  .type _ZN4FMOD6System15getNestedPluginEjiPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System15getNestedPluginEjiPj
#endif
_ZN4FMOD6System15getNestedPluginEjiPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3908+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $977, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System15getNestedPluginEjiPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System15getNetworkProxyEPci
  .p2align 4
  .type _ZN4FMOD6System15getNetworkProxyEPci, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System15getNetworkProxyEPci
#endif
_ZN4FMOD6System15getNetworkProxyEPci:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3912+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $978, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System15getNetworkProxyEPci
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System15getOutputHandleEPPv
  .p2align 4
  .type _ZN4FMOD6System15getOutputHandleEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System15getOutputHandleEPPv
#endif
_ZN4FMOD6System15getOutputHandleEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3916+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $979, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System15getOutputHandleEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System15getPluginHandleE15FMOD_PLUGINTYPEiPj
  .p2align 4
  .type _ZN4FMOD6System15getPluginHandleE15FMOD_PLUGINTYPEiPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System15getPluginHandleE15FMOD_PLUGINTYPEiPj
#endif
_ZN4FMOD6System15getPluginHandleE15FMOD_PLUGINTYPEiPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3920+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $980, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System15getPluginHandleE15FMOD_PLUGINTYPEiPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System15setNetworkProxyEPKc
  .p2align 4
  .type _ZN4FMOD6System15setNetworkProxyEPKc, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System15setNetworkProxyEPKc
#endif
_ZN4FMOD6System15setNetworkProxyEPKc:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3924+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $981, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System15setNetworkProxyEPKc
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System16attachFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_E
  .p2align 4
  .type _ZN4FMOD6System16attachFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_E, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System16attachFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_E
#endif
_ZN4FMOD6System16attachFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_E:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3928+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $982, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System16attachFileSystemEPF11FMOD_RESULTPKcPjPPvS5_EPFS1_S5_S5_EPFS1_S5_S5_jS4_S5_EPFS1_S5_jS5_E
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System16createSoundGroupEPKcPPNS_10SoundGroupE
  .p2align 4
  .type _ZN4FMOD6System16createSoundGroupEPKcPPNS_10SoundGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System16createSoundGroupEPKcPPNS_10SoundGroupE
#endif
_ZN4FMOD6System16createSoundGroupEPKcPPNS_10SoundGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3932+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $983, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System16createSoundGroupEPKcPPNS_10SoundGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System16getDSPBufferSizeEPjPi
  .p2align 4
  .type _ZN4FMOD6System16getDSPBufferSizeEPjPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System16getDSPBufferSizeEPjPi
#endif
_ZN4FMOD6System16getDSPBufferSizeEPjPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3936+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $984, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System16getDSPBufferSizeEPjPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System16getDSPInfoByTypeE13FMOD_DSP_TYPEPPK20FMOD_DSP_DESCRIPTION
  .p2align 4
  .type _ZN4FMOD6System16getDSPInfoByTypeE13FMOD_DSP_TYPEPPK20FMOD_DSP_DESCRIPTION, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System16getDSPInfoByTypeE13FMOD_DSP_TYPEPPK20FMOD_DSP_DESCRIPTION
#endif
_ZN4FMOD6System16getDSPInfoByTypeE13FMOD_DSP_TYPEPPK20FMOD_DSP_DESCRIPTION:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3940+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $985, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System16getDSPInfoByTypeE13FMOD_DSP_TYPEPPK20FMOD_DSP_DESCRIPTION
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System16setDSPBufferSizeEji
  .p2align 4
  .type _ZN4FMOD6System16setDSPBufferSizeEji, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System16setDSPBufferSizeEji
#endif
_ZN4FMOD6System16setDSPBufferSizeEji:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3944+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $986, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System16setDSPBufferSizeEji
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17createDSPByPluginEjPPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD6System17createDSPByPluginEjPPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17createDSPByPluginEjPPNS_3DSPE
#endif
_ZN4FMOD6System17createDSPByPluginEjPPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3948+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $987, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17createDSPByPluginEjPPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17get3DNumListenersEPi
  .p2align 4
  .type _ZN4FMOD6System17get3DNumListenersEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17get3DNumListenersEPi
#endif
_ZN4FMOD6System17get3DNumListenersEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3952+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $988, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17get3DNumListenersEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17getNetworkTimeoutEPi
  .p2align 4
  .type _ZN4FMOD6System17getNetworkTimeoutEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17getNetworkTimeoutEPi
#endif
_ZN4FMOD6System17getNetworkTimeoutEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3956+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $989, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17getNetworkTimeoutEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17getOutputByPluginEPj
  .p2align 4
  .type _ZN4FMOD6System17getOutputByPluginEPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17getOutputByPluginEPj
#endif
_ZN4FMOD6System17getOutputByPluginEPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3960+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $990, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17getOutputByPluginEPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17getRecordPositionEiPj
  .p2align 4
  .type _ZN4FMOD6System17getRecordPositionEiPj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17getRecordPositionEiPj
#endif
_ZN4FMOD6System17getRecordPositionEiPj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3964+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $991, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17getRecordPositionEiPj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17getSoftwareFormatEPiP16FMOD_SPEAKERMODES1_
  .p2align 4
  .type _ZN4FMOD6System17getSoftwareFormatEPiP16FMOD_SPEAKERMODES1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17getSoftwareFormatEPiP16FMOD_SPEAKERMODES1_
#endif
_ZN4FMOD6System17getSoftwareFormatEPiP16FMOD_SPEAKERMODES1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3968+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $992, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17getSoftwareFormatEPiP16FMOD_SPEAKERMODES1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17set3DNumListenersEi
  .p2align 4
  .type _ZN4FMOD6System17set3DNumListenersEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17set3DNumListenersEi
#endif
_ZN4FMOD6System17set3DNumListenersEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3972+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $993, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17set3DNumListenersEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17setNetworkTimeoutEi
  .p2align 4
  .type _ZN4FMOD6System17setNetworkTimeoutEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17setNetworkTimeoutEi
#endif
_ZN4FMOD6System17setNetworkTimeoutEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3976+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $994, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17setNetworkTimeoutEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17setOutputByPluginEj
  .p2align 4
  .type _ZN4FMOD6System17setOutputByPluginEj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17setOutputByPluginEj
#endif
_ZN4FMOD6System17setOutputByPluginEj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3980+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $995, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17setOutputByPluginEj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System17setSoftwareFormatEi16FMOD_SPEAKERMODEi
  .p2align 4
  .type _ZN4FMOD6System17setSoftwareFormatEi16FMOD_SPEAKERMODEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System17setSoftwareFormatEi16FMOD_SPEAKERMODEi
#endif
_ZN4FMOD6System17setSoftwareFormatEi16FMOD_SPEAKERMODEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3984+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $996, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System17setSoftwareFormatEi16FMOD_SPEAKERMODEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System18createChannelGroupEPKcPPNS_12ChannelGroupE
  .p2align 4
  .type _ZN4FMOD6System18createChannelGroupEPKcPPNS_12ChannelGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System18createChannelGroupEPKcPPNS_12ChannelGroupE
#endif
_ZN4FMOD6System18createChannelGroupEPKcPPNS_12ChannelGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3988+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $997, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System18createChannelGroupEPKcPPNS_12ChannelGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System18getChannelsPlayingEPiS1_
  .p2align 4
  .type _ZN4FMOD6System18getChannelsPlayingEPiS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System18getChannelsPlayingEPiS1_
#endif
_ZN4FMOD6System18getChannelsPlayingEPiS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3992+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $998, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System18getChannelsPlayingEPiS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System18getDSPInfoByPluginEjPPK20FMOD_DSP_DESCRIPTION
  .p2align 4
  .type _ZN4FMOD6System18getDSPInfoByPluginEjPPK20FMOD_DSP_DESCRIPTION, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System18getDSPInfoByPluginEjPPK20FMOD_DSP_DESCRIPTION
#endif
_ZN4FMOD6System18getDSPInfoByPluginEjPPK20FMOD_DSP_DESCRIPTION:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 3996+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $999, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System18getDSPInfoByPluginEjPPK20FMOD_DSP_DESCRIPTION
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System18getSpeakerPositionE12FMOD_SPEAKERPfS2_Pb
  .p2align 4
  .type _ZN4FMOD6System18getSpeakerPositionE12FMOD_SPEAKERPfS2_Pb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System18getSpeakerPositionE12FMOD_SPEAKERPfS2_Pb
#endif
_ZN4FMOD6System18getSpeakerPositionE12FMOD_SPEAKERPfS2_Pb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4000+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1000, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System18getSpeakerPositionE12FMOD_SPEAKERPfS2_Pb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System18setSpeakerPositionE12FMOD_SPEAKERffb
  .p2align 4
  .type _ZN4FMOD6System18setSpeakerPositionE12FMOD_SPEAKERffb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System18setSpeakerPositionE12FMOD_SPEAKERffb
#endif
_ZN4FMOD6System18setSpeakerPositionE12FMOD_SPEAKERffb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4004+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1001, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System18setSpeakerPositionE12FMOD_SPEAKERffb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS
  .p2align 4
  .type _ZN4FMOD6System19getAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS
#endif
_ZN4FMOD6System19getAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4008+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1002, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getDefaultMixMatrixE16FMOD_SPEAKERMODES1_Pfi
  .p2align 4
  .type _ZN4FMOD6System19getDefaultMixMatrixE16FMOD_SPEAKERMODES1_Pfi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getDefaultMixMatrixE16FMOD_SPEAKERMODES1_Pfi
#endif
_ZN4FMOD6System19getDefaultMixMatrixE16FMOD_SPEAKERMODES1_Pfi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4012+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1003, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getDefaultMixMatrixE16FMOD_SPEAKERMODES1_Pfi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getGeometrySettingsEPf
  .p2align 4
  .type _ZN4FMOD6System19getGeometrySettingsEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getGeometrySettingsEPf
#endif
_ZN4FMOD6System19getGeometrySettingsEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4016+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1004, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getGeometrySettingsEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getMasterSoundGroupEPPNS_10SoundGroupE
  .p2align 4
  .type _ZN4FMOD6System19getMasterSoundGroupEPPNS_10SoundGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getMasterSoundGroupEPPNS_10SoundGroupE
#endif
_ZN4FMOD6System19getMasterSoundGroupEPPNS_10SoundGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4020+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1005, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getMasterSoundGroupEPPNS_10SoundGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getNumNestedPluginsEjPi
  .p2align 4
  .type _ZN4FMOD6System19getNumNestedPluginsEjPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getNumNestedPluginsEjPi
#endif
_ZN4FMOD6System19getNumNestedPluginsEjPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4024+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1006, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getNumNestedPluginsEjPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getRecordDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_Pj
  .p2align 4
  .type _ZN4FMOD6System19getRecordDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_Pj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getRecordDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_Pj
#endif
_ZN4FMOD6System19getRecordDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_Pj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4028+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1007, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getRecordDriverInfoEiPciP9FMOD_GUIDPiP16FMOD_SPEAKERMODES4_Pj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getRecordNumDriversEPiS1_
  .p2align 4
  .type _ZN4FMOD6System19getRecordNumDriversEPiS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getRecordNumDriversEPiS1_
#endif
_ZN4FMOD6System19getRecordNumDriversEPiS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4032+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1008, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getRecordNumDriversEPiS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getReverbPropertiesEiP22FMOD_REVERB_PROPERTIES
  .p2align 4
  .type _ZN4FMOD6System19getReverbPropertiesEiP22FMOD_REVERB_PROPERTIES, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getReverbPropertiesEiP22FMOD_REVERB_PROPERTIES
#endif
_ZN4FMOD6System19getReverbPropertiesEiP22FMOD_REVERB_PROPERTIES:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4036+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1009, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getReverbPropertiesEiP22FMOD_REVERB_PROPERTIES
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getSoftwareChannelsEPi
  .p2align 4
  .type _ZN4FMOD6System19getSoftwareChannelsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getSoftwareChannelsEPi
#endif
_ZN4FMOD6System19getSoftwareChannelsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4040+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1010, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getSoftwareChannelsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19getStreamBufferSizeEPjS1_
  .p2align 4
  .type _ZN4FMOD6System19getStreamBufferSizeEPjS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19getStreamBufferSizeEPjS1_
#endif
_ZN4FMOD6System19getStreamBufferSizeEPjS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4044+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1011, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19getStreamBufferSizeEPjS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19setAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS
  .p2align 4
  .type _ZN4FMOD6System19setAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19setAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS
#endif
_ZN4FMOD6System19setAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4048+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1012, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19setAdvancedSettingsEP21FMOD_ADVANCEDSETTINGS
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19setGeometrySettingsEf
  .p2align 4
  .type _ZN4FMOD6System19setGeometrySettingsEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19setGeometrySettingsEf
#endif
_ZN4FMOD6System19setGeometrySettingsEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4052+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1013, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19setGeometrySettingsEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19setReverbPropertiesEiPK22FMOD_REVERB_PROPERTIES
  .p2align 4
  .type _ZN4FMOD6System19setReverbPropertiesEiPK22FMOD_REVERB_PROPERTIES, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19setReverbPropertiesEiPK22FMOD_REVERB_PROPERTIES
#endif
_ZN4FMOD6System19setReverbPropertiesEiPK22FMOD_REVERB_PROPERTIES:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4056+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1014, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19setReverbPropertiesEiPK22FMOD_REVERB_PROPERTIES
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19setSoftwareChannelsEi
  .p2align 4
  .type _ZN4FMOD6System19setSoftwareChannelsEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19setSoftwareChannelsEi
#endif
_ZN4FMOD6System19setSoftwareChannelsEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4060+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1015, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19setSoftwareChannelsEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System19setStreamBufferSizeEjj
  .p2align 4
  .type _ZN4FMOD6System19setStreamBufferSizeEjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System19setStreamBufferSizeEjj
#endif
_ZN4FMOD6System19setStreamBufferSizeEjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4064+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1016, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System19setStreamBufferSizeEjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System20getGeometryOcclusionEPK11FMOD_VECTORS3_PfS4_
  .p2align 4
  .type _ZN4FMOD6System20getGeometryOcclusionEPK11FMOD_VECTORS3_PfS4_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System20getGeometryOcclusionEPK11FMOD_VECTORS3_PfS4_
#endif
_ZN4FMOD6System20getGeometryOcclusionEPK11FMOD_VECTORS3_PfS4_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4068+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1017, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System20getGeometryOcclusionEPK11FMOD_VECTORS3_PfS4_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System20set3DRolloffCallbackEPFfP19FMOD_CHANNELCONTROLfE
  .p2align 4
  .type _ZN4FMOD6System20set3DRolloffCallbackEPFfP19FMOD_CHANNELCONTROLfE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System20set3DRolloffCallbackEPFfP19FMOD_CHANNELCONTROLfE
#endif
_ZN4FMOD6System20set3DRolloffCallbackEPFfP19FMOD_CHANNELCONTROLfE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4072+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1018, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System20set3DRolloffCallbackEPFfP19FMOD_CHANNELCONTROLfE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System21getMasterChannelGroupEPPNS_12ChannelGroupE
  .p2align 4
  .type _ZN4FMOD6System21getMasterChannelGroupEPPNS_12ChannelGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System21getMasterChannelGroupEPPNS_12ChannelGroupE
#endif
_ZN4FMOD6System21getMasterChannelGroupEPPNS_12ChannelGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4076+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1019, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System21getMasterChannelGroupEPPNS_12ChannelGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System22getSpeakerModeChannelsE16FMOD_SPEAKERMODEPi
  .p2align 4
  .type _ZN4FMOD6System22getSpeakerModeChannelsE16FMOD_SPEAKERMODEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System22getSpeakerModeChannelsE16FMOD_SPEAKERMODEPi
#endif
_ZN4FMOD6System22getSpeakerModeChannelsE16FMOD_SPEAKERMODEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4080+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1020, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System22getSpeakerModeChannelsE16FMOD_SPEAKERMODEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System23get3DListenerAttributesEiP11FMOD_VECTORS2_S2_S2_
  .p2align 4
  .type _ZN4FMOD6System23get3DListenerAttributesEiP11FMOD_VECTORS2_S2_S2_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System23get3DListenerAttributesEiP11FMOD_VECTORS2_S2_S2_
#endif
_ZN4FMOD6System23get3DListenerAttributesEiP11FMOD_VECTORS2_S2_S2_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4084+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1021, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System23get3DListenerAttributesEiP11FMOD_VECTORS2_S2_S2_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System23set3DListenerAttributesEiPK11FMOD_VECTORS3_S3_S3_
  .p2align 4
  .type _ZN4FMOD6System23set3DListenerAttributesEiPK11FMOD_VECTORS3_S3_S3_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System23set3DListenerAttributesEiPK11FMOD_VECTORS3_S3_S3_
#endif
_ZN4FMOD6System23set3DListenerAttributesEiPK11FMOD_VECTORS3_S3_S3_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4088+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1022, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System23set3DListenerAttributesEiPK11FMOD_VECTORS3_S3_S3_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System24attachChannelGroupToPortE14FMOD_PORT_TYPEyPNS_12ChannelGroupEb
  .p2align 4
  .type _ZN4FMOD6System24attachChannelGroupToPortE14FMOD_PORT_TYPEyPNS_12ChannelGroupEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System24attachChannelGroupToPortE14FMOD_PORT_TYPEyPNS_12ChannelGroupEb
#endif
_ZN4FMOD6System24attachChannelGroupToPortE14FMOD_PORT_TYPEyPNS_12ChannelGroupEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4092+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1023, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System24attachChannelGroupToPortE14FMOD_PORT_TYPEyPNS_12ChannelGroupEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System26detachChannelGroupFromPortEPNS_12ChannelGroupE
  .p2align 4
  .type _ZN4FMOD6System26detachChannelGroupFromPortEPNS_12ChannelGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System26detachChannelGroupFromPortEPNS_12ChannelGroupE
#endif
_ZN4FMOD6System26detachChannelGroupFromPortEPNS_12ChannelGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4096+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1024, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System26detachChannelGroupFromPortEPNS_12ChannelGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System4initEijPv
  .p2align 4
  .type _ZN4FMOD6System4initEijPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System4initEijPv
#endif
_ZN4FMOD6System4initEijPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4100+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1025, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System4initEijPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System5closeEv
  .p2align 4
  .type _ZN4FMOD6System5closeEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System5closeEv
#endif
_ZN4FMOD6System5closeEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4104+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1026, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System5closeEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System6updateEv
  .p2align 4
  .type _ZN4FMOD6System6updateEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System6updateEv
#endif
_ZN4FMOD6System6updateEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4108+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1027, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System6updateEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System7lockDSPEv
  .p2align 4
  .type _ZN4FMOD6System7lockDSPEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System7lockDSPEv
#endif
_ZN4FMOD6System7lockDSPEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4112+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1028, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System7lockDSPEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System7playDSPEPNS_3DSPEPNS_12ChannelGroupEbPPNS_7ChannelE
  .p2align 4
  .type _ZN4FMOD6System7playDSPEPNS_3DSPEPNS_12ChannelGroupEbPPNS_7ChannelE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System7playDSPEPNS_3DSPEPNS_12ChannelGroupEbPPNS_7ChannelE
#endif
_ZN4FMOD6System7playDSPEPNS_3DSPEPNS_12ChannelGroupEbPPNS_7ChannelE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4116+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1029, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System7playDSPEPNS_3DSPEPNS_12ChannelGroupEbPPNS_7ChannelE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System7releaseEv
  .p2align 4
  .type _ZN4FMOD6System7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System7releaseEv
#endif
_ZN4FMOD6System7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4120+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1030, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9createDSPEPK20FMOD_DSP_DESCRIPTIONPPNS_3DSPE
  .p2align 4
  .type _ZN4FMOD6System9createDSPEPK20FMOD_DSP_DESCRIPTIONPPNS_3DSPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9createDSPEPK20FMOD_DSP_DESCRIPTIONPPNS_3DSPE
#endif
_ZN4FMOD6System9createDSPEPK20FMOD_DSP_DESCRIPTIONPPNS_3DSPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4124+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1031, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9createDSPEPK20FMOD_DSP_DESCRIPTIONPPNS_3DSPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9getDriverEPi
  .p2align 4
  .type _ZN4FMOD6System9getDriverEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9getDriverEPi
#endif
_ZN4FMOD6System9getDriverEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4128+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1032, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9getDriverEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9getOutputEP15FMOD_OUTPUTTYPE
  .p2align 4
  .type _ZN4FMOD6System9getOutputEP15FMOD_OUTPUTTYPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9getOutputEP15FMOD_OUTPUTTYPE
#endif
_ZN4FMOD6System9getOutputEP15FMOD_OUTPUTTYPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4132+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1033, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9getOutputEP15FMOD_OUTPUTTYPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9playSoundEPNS_5SoundEPNS_12ChannelGroupEbPPNS_7ChannelE
  .p2align 4
  .type _ZN4FMOD6System9playSoundEPNS_5SoundEPNS_12ChannelGroupEbPPNS_7ChannelE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9playSoundEPNS_5SoundEPNS_12ChannelGroupEbPPNS_7ChannelE
#endif
_ZN4FMOD6System9playSoundEPNS_5SoundEPNS_12ChannelGroupEbPPNS_7ChannelE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4136+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1034, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9playSoundEPNS_5SoundEPNS_12ChannelGroupEbPPNS_7ChannelE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9setDriverEi
  .p2align 4
  .type _ZN4FMOD6System9setDriverEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9setDriverEi
#endif
_ZN4FMOD6System9setDriverEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4140+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1035, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9setDriverEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9setOutputE15FMOD_OUTPUTTYPE
  .p2align 4
  .type _ZN4FMOD6System9setOutputE15FMOD_OUTPUTTYPE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9setOutputE15FMOD_OUTPUTTYPE
#endif
_ZN4FMOD6System9setOutputE15FMOD_OUTPUTTYPE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4144+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1036, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9setOutputE15FMOD_OUTPUTTYPE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD6System9unlockDSPEv
  .p2align 4
  .type _ZN4FMOD6System9unlockDSPEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD6System9unlockDSPEv
#endif
_ZN4FMOD6System9unlockDSPEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4148+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1037, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD6System9unlockDSPEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel11getPositionEPjj
  .p2align 4
  .type _ZN4FMOD7Channel11getPositionEPjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel11getPositionEPjj
#endif
_ZN4FMOD7Channel11getPositionEPjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4152+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1038, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel11getPositionEPjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel11getPriorityEPi
  .p2align 4
  .type _ZN4FMOD7Channel11getPriorityEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel11getPriorityEPi
#endif
_ZN4FMOD7Channel11getPriorityEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4156+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1039, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel11getPriorityEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel11setPositionEjj
  .p2align 4
  .type _ZN4FMOD7Channel11setPositionEjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel11setPositionEjj
#endif
_ZN4FMOD7Channel11setPositionEjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4160+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1040, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel11setPositionEjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel11setPriorityEi
  .p2align 4
  .type _ZN4FMOD7Channel11setPriorityEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel11setPriorityEi
#endif
_ZN4FMOD7Channel11setPriorityEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4164+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1041, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel11setPriorityEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel12getFrequencyEPf
  .p2align 4
  .type _ZN4FMOD7Channel12getFrequencyEPf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel12getFrequencyEPf
#endif
_ZN4FMOD7Channel12getFrequencyEPf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4168+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1042, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel12getFrequencyEPf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel12getLoopCountEPi
  .p2align 4
  .type _ZN4FMOD7Channel12getLoopCountEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel12getLoopCountEPi
#endif
_ZN4FMOD7Channel12getLoopCountEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4172+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1043, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel12getLoopCountEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel12setFrequencyEf
  .p2align 4
  .type _ZN4FMOD7Channel12setFrequencyEf, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel12setFrequencyEf
#endif
_ZN4FMOD7Channel12setFrequencyEf:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4176+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1044, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel12setFrequencyEf
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel12setLoopCountEi
  .p2align 4
  .type _ZN4FMOD7Channel12setLoopCountEi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel12setLoopCountEi
#endif
_ZN4FMOD7Channel12setLoopCountEi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4180+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1045, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel12setLoopCountEi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel13getLoopPointsEPjjS1_j
  .p2align 4
  .type _ZN4FMOD7Channel13getLoopPointsEPjjS1_j, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel13getLoopPointsEPjjS1_j
#endif
_ZN4FMOD7Channel13getLoopPointsEPjjS1_j:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4184+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1046, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel13getLoopPointsEPjjS1_j
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel13setLoopPointsEjjjj
  .p2align 4
  .type _ZN4FMOD7Channel13setLoopPointsEjjjj, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel13setLoopPointsEjjjj
#endif
_ZN4FMOD7Channel13setLoopPointsEjjjj:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4188+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1047, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel13setLoopPointsEjjjj
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel15getChannelGroupEPPNS_12ChannelGroupE
  .p2align 4
  .type _ZN4FMOD7Channel15getChannelGroupEPPNS_12ChannelGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel15getChannelGroupEPPNS_12ChannelGroupE
#endif
_ZN4FMOD7Channel15getChannelGroupEPPNS_12ChannelGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4192+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1048, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel15getChannelGroupEPPNS_12ChannelGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel15getCurrentSoundEPPNS_5SoundE
  .p2align 4
  .type _ZN4FMOD7Channel15getCurrentSoundEPPNS_5SoundE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel15getCurrentSoundEPPNS_5SoundE
#endif
_ZN4FMOD7Channel15getCurrentSoundEPPNS_5SoundE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4196+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1049, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel15getCurrentSoundEPPNS_5SoundE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel15setChannelGroupEPNS_12ChannelGroupE
  .p2align 4
  .type _ZN4FMOD7Channel15setChannelGroupEPNS_12ChannelGroupE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel15setChannelGroupEPNS_12ChannelGroupE
#endif
_ZN4FMOD7Channel15setChannelGroupEPNS_12ChannelGroupE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4200+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1050, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel15setChannelGroupEPNS_12ChannelGroupE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel8getIndexEPi
  .p2align 4
  .type _ZN4FMOD7Channel8getIndexEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel8getIndexEPi
#endif
_ZN4FMOD7Channel8getIndexEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4204+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1051, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel8getIndexEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7Channel9isVirtualEPb
  .p2align 4
  .type _ZN4FMOD7Channel9isVirtualEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7Channel9isVirtualEPb
#endif
_ZN4FMOD7Channel9isVirtualEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4208+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1052, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7Channel9isVirtualEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7SystemI14createDiskFileEPKcP22FMOD_CREATESOUNDEXINFOPPNS_4FileEPb
  .p2align 4
  .type _ZN4FMOD7SystemI14createDiskFileEPKcP22FMOD_CREATESOUNDEXINFOPPNS_4FileEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7SystemI14createDiskFileEPKcP22FMOD_CREATESOUNDEXINFOPPNS_4FileEPb
#endif
_ZN4FMOD7SystemI14createDiskFileEPKcP22FMOD_CREATESOUNDEXINFOPPNS_4FileEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4212+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1053, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7SystemI14createDiskFileEPKcP22FMOD_CREATESOUNDEXINFOPPNS_4FileEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7SystemI16createMemoryFileEPPNS_4FileE
  .p2align 4
  .type _ZN4FMOD7SystemI16createMemoryFileEPPNS_4FileE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7SystemI16createMemoryFileEPPNS_4FileE
#endif
_ZN4FMOD7SystemI16createMemoryFileEPPNS_4FileE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4216+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1054, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7SystemI16createMemoryFileEPPNS_4FileE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7SystemI19createClientProfileEv
  .p2align 4
  .type _ZN4FMOD7SystemI19createClientProfileEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7SystemI19createClientProfileEv
#endif
_ZN4FMOD7SystemI19createClientProfileEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4220+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1055, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7SystemI19createClientProfileEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7SystemI19setInternalCallbackEiPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_ES4_
  .p2align 4
  .type _ZN4FMOD7SystemI19setInternalCallbackEiPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_ES4_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7SystemI19setInternalCallbackEiPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_ES4_
#endif
_ZN4FMOD7SystemI19setInternalCallbackEiPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_ES4_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4224+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1056, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7SystemI19setInternalCallbackEiPF11FMOD_RESULTP11FMOD_SYSTEMjPvS4_S4_ES4_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD7SystemI8validateEPNS_6SystemEPPS0_PNS_15SystemLockScopeE
  .p2align 4
  .type _ZN4FMOD7SystemI8validateEPNS_6SystemEPPS0_PNS_15SystemLockScopeE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD7SystemI8validateEPNS_6SystemEPPS0_PNS_15SystemLockScopeE
#endif
_ZN4FMOD7SystemI8validateEPNS_6SystemEPPS0_PNS_15SystemLockScopeE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4228+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1057, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD7SystemI8validateEPNS_6SystemEPPS0_PNS_15SystemLockScopeE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8ChannelI8validateEPNS_7ChannelEPPS0_PNS_15SystemLockScopeE
  .p2align 4
  .type _ZN4FMOD8ChannelI8validateEPNS_7ChannelEPPS0_PNS_15SystemLockScopeE, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8ChannelI8validateEPNS_7ChannelEPPS0_PNS_15SystemLockScopeE
#endif
_ZN4FMOD8ChannelI8validateEPNS_7ChannelEPPS0_PNS_15SystemLockScopeE:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4232+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1058, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8ChannelI8validateEPNS_7ChannelEPPS0_PNS_15SystemLockScopeE
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry10addPolygonEffbiPK11FMOD_VECTORPi
  .p2align 4
  .type _ZN4FMOD8Geometry10addPolygonEffbiPK11FMOD_VECTORPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry10addPolygonEffbiPK11FMOD_VECTORPi
#endif
_ZN4FMOD8Geometry10addPolygonEffbiPK11FMOD_VECTORPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4236+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1059, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry10addPolygonEffbiPK11FMOD_VECTORPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry11getPositionEP11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD8Geometry11getPositionEP11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry11getPositionEP11FMOD_VECTOR
#endif
_ZN4FMOD8Geometry11getPositionEP11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4240+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1060, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry11getPositionEP11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry11getRotationEP11FMOD_VECTORS2_
  .p2align 4
  .type _ZN4FMOD8Geometry11getRotationEP11FMOD_VECTORS2_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry11getRotationEP11FMOD_VECTORS2_
#endif
_ZN4FMOD8Geometry11getRotationEP11FMOD_VECTORS2_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4244+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1061, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry11getRotationEP11FMOD_VECTORS2_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD8Geometry11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry11getUserDataEPPv
#endif
_ZN4FMOD8Geometry11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4248+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1062, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry11setPositionEPK11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD8Geometry11setPositionEPK11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry11setPositionEPK11FMOD_VECTOR
#endif
_ZN4FMOD8Geometry11setPositionEPK11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4252+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1063, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry11setPositionEPK11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry11setRotationEPK11FMOD_VECTORS3_
  .p2align 4
  .type _ZN4FMOD8Geometry11setRotationEPK11FMOD_VECTORS3_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry11setRotationEPK11FMOD_VECTORS3_
#endif
_ZN4FMOD8Geometry11setRotationEPK11FMOD_VECTORS3_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4256+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1064, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry11setRotationEPK11FMOD_VECTORS3_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD8Geometry11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry11setUserDataEPv
#endif
_ZN4FMOD8Geometry11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4260+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1065, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry14getMaxPolygonsEPiS1_
  .p2align 4
  .type _ZN4FMOD8Geometry14getMaxPolygonsEPiS1_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry14getMaxPolygonsEPiS1_
#endif
_ZN4FMOD8Geometry14getMaxPolygonsEPiS1_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4264+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1066, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry14getMaxPolygonsEPiS1_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry14getNumPolygonsEPi
  .p2align 4
  .type _ZN4FMOD8Geometry14getNumPolygonsEPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry14getNumPolygonsEPi
#endif
_ZN4FMOD8Geometry14getNumPolygonsEPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4268+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1067, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry14getNumPolygonsEPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry16getPolygonVertexEiiP11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD8Geometry16getPolygonVertexEiiP11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry16getPolygonVertexEiiP11FMOD_VECTOR
#endif
_ZN4FMOD8Geometry16getPolygonVertexEiiP11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4272+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1068, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry16getPolygonVertexEiiP11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry16setPolygonVertexEiiPK11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD8Geometry16setPolygonVertexEiiPK11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry16setPolygonVertexEiiPK11FMOD_VECTOR
#endif
_ZN4FMOD8Geometry16setPolygonVertexEiiPK11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4276+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1069, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry16setPolygonVertexEiiPK11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry20getPolygonAttributesEiPfS1_Pb
  .p2align 4
  .type _ZN4FMOD8Geometry20getPolygonAttributesEiPfS1_Pb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry20getPolygonAttributesEiPfS1_Pb
#endif
_ZN4FMOD8Geometry20getPolygonAttributesEiPfS1_Pb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4280+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1070, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry20getPolygonAttributesEiPfS1_Pb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry20setPolygonAttributesEiffb
  .p2align 4
  .type _ZN4FMOD8Geometry20setPolygonAttributesEiffb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry20setPolygonAttributesEiffb
#endif
_ZN4FMOD8Geometry20setPolygonAttributesEiffb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4284+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1071, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry20setPolygonAttributesEiffb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry21getPolygonNumVerticesEiPi
  .p2align 4
  .type _ZN4FMOD8Geometry21getPolygonNumVerticesEiPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry21getPolygonNumVerticesEiPi
#endif
_ZN4FMOD8Geometry21getPolygonNumVerticesEiPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4288+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1072, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry21getPolygonNumVerticesEiPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry4saveEPvPi
  .p2align 4
  .type _ZN4FMOD8Geometry4saveEPvPi, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry4saveEPvPi
#endif
_ZN4FMOD8Geometry4saveEPvPi:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4292+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1073, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry4saveEPvPi
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry7releaseEv
  .p2align 4
  .type _ZN4FMOD8Geometry7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry7releaseEv
#endif
_ZN4FMOD8Geometry7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4296+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1074, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry8getScaleEP11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD8Geometry8getScaleEP11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry8getScaleEP11FMOD_VECTOR
#endif
_ZN4FMOD8Geometry8getScaleEP11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4300+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1075, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry8getScaleEP11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry8setScaleEPK11FMOD_VECTOR
  .p2align 4
  .type _ZN4FMOD8Geometry8setScaleEPK11FMOD_VECTOR, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry8setScaleEPK11FMOD_VECTOR
#endif
_ZN4FMOD8Geometry8setScaleEPK11FMOD_VECTOR:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4304+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1076, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry8setScaleEPK11FMOD_VECTOR
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry9getActiveEPb
  .p2align 4
  .type _ZN4FMOD8Geometry9getActiveEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry9getActiveEPb
#endif
_ZN4FMOD8Geometry9getActiveEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4308+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1077, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry9getActiveEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Geometry9setActiveEb
  .p2align 4
  .type _ZN4FMOD8Geometry9setActiveEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Geometry9setActiveEb
#endif
_ZN4FMOD8Geometry9setActiveEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4312+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1078, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Geometry9setActiveEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD8Reverb3D11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D11getUserDataEPPv
#endif
_ZN4FMOD8Reverb3D11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4316+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1079, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD8Reverb3D11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D11setUserDataEPv
#endif
_ZN4FMOD8Reverb3D11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4320+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1080, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D11setUserDataEPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D13getPropertiesEP22FMOD_REVERB_PROPERTIES
  .p2align 4
  .type _ZN4FMOD8Reverb3D13getPropertiesEP22FMOD_REVERB_PROPERTIES, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D13getPropertiesEP22FMOD_REVERB_PROPERTIES
#endif
_ZN4FMOD8Reverb3D13getPropertiesEP22FMOD_REVERB_PROPERTIES:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4324+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1081, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D13getPropertiesEP22FMOD_REVERB_PROPERTIES
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D13setPropertiesEPK22FMOD_REVERB_PROPERTIES
  .p2align 4
  .type _ZN4FMOD8Reverb3D13setPropertiesEPK22FMOD_REVERB_PROPERTIES, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D13setPropertiesEPK22FMOD_REVERB_PROPERTIES
#endif
_ZN4FMOD8Reverb3D13setPropertiesEPK22FMOD_REVERB_PROPERTIES:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4328+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1082, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D13setPropertiesEPK22FMOD_REVERB_PROPERTIES
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D15get3DAttributesEP11FMOD_VECTORPfS3_
  .p2align 4
  .type _ZN4FMOD8Reverb3D15get3DAttributesEP11FMOD_VECTORPfS3_, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D15get3DAttributesEP11FMOD_VECTORPfS3_
#endif
_ZN4FMOD8Reverb3D15get3DAttributesEP11FMOD_VECTORPfS3_:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4332+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1083, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D15get3DAttributesEP11FMOD_VECTORPfS3_
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D15set3DAttributesEPK11FMOD_VECTORff
  .p2align 4
  .type _ZN4FMOD8Reverb3D15set3DAttributesEPK11FMOD_VECTORff, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D15set3DAttributesEPK11FMOD_VECTORff
#endif
_ZN4FMOD8Reverb3D15set3DAttributesEPK11FMOD_VECTORff:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4336+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1084, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D15set3DAttributesEPK11FMOD_VECTORff
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D7releaseEv
  .p2align 4
  .type _ZN4FMOD8Reverb3D7releaseEv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D7releaseEv
#endif
_ZN4FMOD8Reverb3D7releaseEv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4340+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1085, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D7releaseEv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D9getActiveEPb
  .p2align 4
  .type _ZN4FMOD8Reverb3D9getActiveEPb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D9getActiveEPb
#endif
_ZN4FMOD8Reverb3D9getActiveEPb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4344+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1086, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D9getActiveEPb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD8Reverb3D9setActiveEb
  .p2align 4
  .type _ZN4FMOD8Reverb3D9setActiveEb, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD8Reverb3D9setActiveEb
#endif
_ZN4FMOD8Reverb3D9setActiveEb:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4348+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1087, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD8Reverb3D9setActiveEb
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD9GeometryI11getUserDataEPPv
  .p2align 4
  .type _ZN4FMOD9GeometryI11getUserDataEPPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD9GeometryI11getUserDataEPPv
#endif
_ZN4FMOD9GeometryI11getUserDataEPPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4352+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1088, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD9GeometryI11getUserDataEPPv
  .cfi_endproc
/*
 * Copyright 2019-2021 Yury Gribov
 *
 * The MIT License (MIT)
 *
 * Use of this source code is governed by MIT license that can be
 * found in the LICENSE.txt file.
 */

  .globl _ZN4FMOD9GeometryI11setUserDataEPv
  .p2align 4
  .type _ZN4FMOD9GeometryI11setUserDataEPv, %function
#ifndef IMPLIB_EXPORT_SHIMS
  .hidden _ZN4FMOD9GeometryI11setUserDataEPv
#endif
_ZN4FMOD9GeometryI11setUserDataEPv:
  .cfi_startproc
  .cfi_def_cfa_offset 4  // Return address
  // add $0, %rsp  Why GDB fails to step over call without this?!
  // x86 has no support for PC-relative addressing so code is not very efficient.
  // We also trash EAX here (it's call-clobbered in cdecl).
  call __implib.x86.get_pc_thunk.ax
  addl $_GLOBAL_OFFSET_TABLE_, %eax
  movl 4356+_libfmod_so_tramp_table@GOTOFF(%eax), %eax
  cmp $0, %eax
  je 2f
1:
  jmp *%eax
2:
  mov $1089, %eax
  call _libfmod_so_save_regs_and_resolve
  jmp _ZN4FMOD9GeometryI11setUserDataEPv
  .cfi_endproc
